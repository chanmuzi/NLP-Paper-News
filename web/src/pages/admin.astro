---
import Layout from '../layouts/Layout.astro';

// Get current date info for defaults
const now = new Date();
const currentYear = now.getFullYear().toString();
const currentMonth = (now.getMonth() + 1).toString();
// ISO week: calculate week of month
const firstDay = new Date(now.getFullYear(), now.getMonth(), 1).getDay();
const currentWeek = Math.ceil((now.getDate() + firstDay) / 7).toString();
---

<Layout title="í•­ëª© ì¶”ê°€ - chanmuzi AI íë ˆì´ì…˜">
  <section class="max-w-3xl mx-auto">
    <!-- Header -->
    <div class="flex items-center gap-3 mb-4">
      <a href={`${import.meta.env.BASE_URL}`} class="text-gray-400 hover:text-claude-500 transition-colors text-sm">
        <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
        í™ˆ
      </a>
    </div>

    <div class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-2xl font-bold text-gray-900 dark:text-gray-100 mb-1">ìƒˆ í•­ëª© ì¶”ê°€</h1>
        <p class="text-sm text-gray-500 dark:text-gray-400">ê°„í¸í•˜ê²Œ ë˜ëŠ” ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ í•­ëª©ì„ ì¶”ê°€í•˜ì„¸ìš”</p>
      </div>
      <!-- GitHub Token -->
      <button id="toggle-settings" class="flex items-center gap-1.5 px-3 py-1.5 rounded-lg border border-gray-200 dark:border-gray-700 text-xs text-gray-500 hover:border-claude-400 hover:text-claude-500 transition-all">
        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.066 2.573c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.573 1.066c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.066-2.573c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
        GitHub
        <span id="token-status" class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded-full text-xs"></span>
      </button>
    </div>

    <!-- GitHub Settings Panel -->
    <div id="settings-panel" class="hidden mb-6 p-4 bg-white dark:bg-anthro-darkSurface rounded-xl border border-gray-200 dark:border-gray-800">
      <p class="text-xs text-gray-500 mb-3">
        GitHub Personal Access Tokenì„ ì…ë ¥í•˜ë©´ ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ í•­ëª©ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br/>
        í† í°ì€ ë¸Œë¼ìš°ì € localStorageì—ë§Œ ì €ì¥ë©ë‹ˆë‹¤.
      </p>
      <div class="flex gap-2">
        <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
          class="flex-1 px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500 transition-all font-mono" />
        <button id="save-token" class="px-4 py-2 rounded-lg bg-claude-500 text-white text-sm font-medium hover:bg-claude-600 transition-all">ì €ì¥</button>
        <button id="clear-token" class="px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 text-sm text-gray-500 hover:text-red-500 hover:border-red-300 transition-all">ì‚­ì œ</button>
      </div>
      <div class="mt-3">
        <label class="block text-xs text-gray-500 mb-1">Repository (owner/repo)</label>
        <input type="text" id="github-repo" value="chanmuzi/NLP-Paper-News"
          class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500 transition-all font-mono" />
      </div>
      <label class="mt-3 flex items-start gap-2 text-xs text-gray-600 dark:text-gray-300">
        <input type="checkbox" id="mock-mode-toggle" class="mt-0.5 accent-claude-500" />
        <span>ë¡œì»¬ mock ëª¨ë“œ (GitHub ì—†ì´ UI íë¦„ í…ŒìŠ¤íŠ¸)</span>
      </label>
    </div>

    <!-- Date (shared) -->
    <div class="flex items-center gap-3 mb-5 bg-white dark:bg-anthro-darkSurface rounded-xl border border-gray-200 dark:border-gray-800 px-4 py-3">
      <span class="text-xs font-semibold text-gray-500 uppercase tracking-wider">ë‚ ì§œ</span>
      <div class="flex items-center gap-2">
        <input type="number" id="input-year" value={currentYear} min="2020" max="2030"
          class="w-[4.5rem] px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500 transition-all font-mono text-center" />
        <span class="text-gray-400 text-xs">ë…„</span>
        <input type="number" id="input-month" value={currentMonth} min="1" max="12"
          class="w-14 px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500 transition-all font-mono text-center" />
        <span class="text-gray-400 text-xs">ì›”</span>
        <input type="number" id="input-week" value={currentWeek} min="1" max="5"
          class="w-14 px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500 transition-all font-mono text-center" />
        <span class="text-gray-400 text-xs">ì£¼ì°¨</span>
      </div>
      <span class="ml-auto text-xs text-gray-400">ìë™ ì„¤ì •ë¨</span>
    </div>

    <!-- Mode Tabs -->
    <div class="flex mb-5 bg-gray-100 dark:bg-anthro-darkMid rounded-lg p-0.5">
      <button id="tab-markdown" class="tab-btn flex-1 py-2 rounded-md text-sm font-semibold transition-all bg-white dark:bg-anthro-darkSurface text-gray-900 dark:text-gray-100 shadow-sm">
        ë§ˆí¬ë‹¤ìš´ ë¶™ì—¬ë„£ê¸°
      </button>
      <button id="tab-simple" class="tab-btn flex-1 py-2 rounded-md text-sm font-semibold transition-all text-gray-500 dark:text-gray-400">
        ê°„í¸ ì¶”ê°€
      </button>
    </div>

    <!-- Simple Mode -->
    <div id="panel-simple" class="hidden bg-white dark:bg-anthro-darkSurface rounded-xl border border-gray-200 dark:border-gray-800 p-5 mb-5">
      <!-- Type Selector -->
      <div class="mb-4">
        <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">ìœ í˜•</label>
        <div class="flex gap-2" id="type-selector">
          <button data-type="paper" class="type-btn active flex-1 py-2.5 rounded-lg border-2 border-claude-400 bg-claude-50 dark:bg-claude-950/20 text-sm font-semibold text-claude-700 dark:text-claude-300 transition-all">
            ğŸ“œ Paper
          </button>
          <button data-type="dev" class="type-btn flex-1 py-2.5 rounded-lg border-2 border-gray-200 dark:border-gray-700 text-sm font-semibold text-gray-500 dark:text-gray-400 transition-all hover:border-anthro-green-500">
            ğŸ§‘ğŸ»â€ğŸ’» Dev
          </button>
          <button data-type="news" class="type-btn flex-1 py-2.5 rounded-lg border-2 border-gray-200 dark:border-gray-700 text-sm font-semibold text-gray-500 dark:text-gray-400 transition-all hover:border-anthro-blue-500">
            ğŸ—ï¸ News
          </button>
        </div>
      </div>

      <!-- Org -->
      <div class="mb-3">
        <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1.5">ê¸°ê´€ëª…</label>
        <input type="text" id="simple-org" placeholder="ì˜ˆ: Anthropic, Google DeepMind"
          class="w-full px-3 py-2.5 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 placeholder-gray-400 outline-none focus:border-claude-500 transition-all" />
      </div>

      <!-- Title -->
      <div class="mb-3">
        <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1.5">ì œëª©</label>
        <input type="text" id="simple-title" placeholder="ì˜ˆ: Constitutional AI: Harmlessness from AI Feedback"
          class="w-full px-3 py-2.5 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 placeholder-gray-400 outline-none focus:border-claude-500 transition-all" />
      </div>

      <!-- URL -->
      <div class="mb-3">
        <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1.5">URL</label>
        <input type="url" id="simple-url" placeholder="https://arxiv.org/abs/..."
          class="w-full px-3 py-2.5 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 placeholder-gray-400 outline-none focus:border-claude-500 transition-all font-mono" />
      </div>

      <!-- Bullets -->
      <div class="mb-4">
        <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1.5">
          ì„¤ëª… <span class="font-normal normal-case tracking-normal text-gray-400">(ì¤„ë§ˆë‹¤ í•˜ë‚˜ì”©, íƒ­ ë˜ëŠ” 4ì¹¸ìœ¼ë¡œ í•˜ìœ„ ì„¤ëª…)</span>
        </label>
        <textarea id="simple-bullets" rows="5"
          placeholder="ì£¼ìš” ë‚´ìš© ì²« ë²ˆì§¸ ì¤„
í•˜ìœ„ ì„¤ëª…ì€ íƒ­ ë˜ëŠ” 4ì¹¸ ë“¤ì—¬ì“°ê¸°
    ì´ëŸ° ì‹ìœ¼ë¡œ í•˜ìœ„ ì„¤ëª… ì¶”ê°€"
          class="w-full px-3 py-2.5 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 placeholder-gray-400 outline-none focus:border-claude-500 transition-all font-mono leading-relaxed"></textarea>
      </div>

      <button id="simple-add-btn" class="w-full px-5 py-2.5 bg-claude-500 text-white rounded-lg text-sm font-semibold hover:bg-claude-600 transition-all shadow-sm">
        ë¯¸ë¦¬ë³´ê¸°ì— ì¶”ê°€
      </button>
    </div>

    <!-- Markdown Mode -->
    <div id="panel-markdown" class="bg-white dark:bg-anthro-darkSurface rounded-xl border border-gray-200 dark:border-gray-800 p-5 mb-5">
      <div class="mb-3">
        <label class="text-xs font-semibold text-gray-500 uppercase tracking-wider">ë§ˆí¬ë‹¤ìš´ ì…ë ¥</label>
      </div>

      <!-- Fallback type for markdown without emoji -->
      <div class="flex items-center gap-2 mb-3">
        <span class="text-xs text-gray-500">ì´ëª¨ì§€ ì—†ëŠ” í•­ëª©ì˜ ê¸°ë³¸ ìœ í˜•:</span>
        <select id="md-fallback-type" class="px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-xs text-gray-700 dark:text-gray-300 outline-none focus:border-claude-500">
          <option value="paper">ğŸ“œ Paper</option>
          <option value="dev">ğŸ§‘ğŸ»â€ğŸ’» Dev</option>
          <option value="news">ğŸ—ï¸ News</option>
        </select>
      </div>

      <textarea
        id="markdown-input"
        rows="12"
        placeholder="- ğŸ“œ [Anthropic] [Constitutional AI: Harmlessness from AI Feedback](https://arxiv.org/abs/2212.08073)
    - RLHF ëŒ€ì‹  AI í”¼ë“œë°±ìœ¼ë¡œ í—Œë²• ì›ì¹™ì„ í•™ìŠµí•˜ëŠ” ë°©ë²• ì œì•ˆ
        - ê¸°ì¡´ RLHFì˜ ì¸ê°„ í”¼ë“œë°± ì˜ì¡´ë„ë¥¼ ì¤„ì´ë©´ì„œ ì•ˆì „ì„± í–¥ìƒ
- ğŸ§‘ğŸ»â€ğŸ’» [Google DeepMind] [Gemma 3 Released](https://blog.google/gemma-3)
    - ì˜¤í”ˆ ì›¨ì´íŠ¸ ëª¨ë¸ Gemma 3 ê³µê°œ, ë‹¤êµ­ì–´ ì§€ì› ê°•í™”
- ğŸ—ï¸ [OpenAI] [GPT-5 ë°œí‘œ](https://openai.com/gpt-5)
    - ì°¨ì„¸ëŒ€ ëª¨ë¸ GPT-5 ê³µì‹ ë°œí‘œ"
        class="w-full px-4 py-3 rounded-xl border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 outline-none focus:border-claude-500 transition-all font-mono leading-relaxed"
      ></textarea>

      <div class="mt-3 flex gap-2">
        <button id="parse-btn" class="flex-1 px-5 py-2.5 bg-claude-500 text-white rounded-lg text-sm font-semibold hover:bg-claude-600 transition-all shadow-sm">
          íŒŒì‹± ë¯¸ë¦¬ë³´ê¸°
        </button>
        <button id="clear-md-btn" class="px-4 py-2.5 rounded-lg border border-gray-200 dark:border-gray-700 text-sm text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-all">
          ì§€ìš°ê¸°
        </button>
      </div>

      <!-- Parse errors -->
      <div id="parse-errors" class="hidden mt-3 p-3 rounded-lg bg-amber-50 dark:bg-amber-950/20 border border-amber-200 dark:border-amber-800 text-xs text-amber-700 dark:text-amber-300"></div>
      <div id="parse-summary" class="hidden mt-3 p-3 rounded-lg bg-gray-50 dark:bg-anthro-darkMid border border-gray-200 dark:border-gray-700 text-xs text-gray-600 dark:text-gray-300"></div>
    </div>

    <!-- Preview -->
    <div id="preview-section" class="hidden mb-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-sm font-semibold text-gray-500 uppercase tracking-wider">
          ë¯¸ë¦¬ë³´ê¸° <span id="preview-count" class="text-claude-500 font-mono">0</span>ê±´
        </h2>
        <button id="clear-preview" class="text-xs text-gray-400 hover:text-red-500 transition-colors">ì „ì²´ ì‚­ì œ</button>
      </div>
      <div id="preview-container" class="space-y-3"></div>

      <!-- Actions -->
      <div class="mt-3 flex gap-2">
        <button id="submit-btn" class="flex-1 px-5 py-2.5 bg-claude-500 text-white rounded-lg text-sm font-semibold hover:bg-claude-600 transition-all shadow-sm disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2">
          <svg class="submit-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
          <svg class="submit-spinner hidden w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
          </svg>
          <span id="submit-btn-label">í™•ì¸í•˜ê³  ì¶”ê°€</span>
        </button>
        <button id="copy-json" class="px-4 py-2.5 rounded-lg border border-gray-200 dark:border-gray-700 text-sm text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-all">
          JSON ë³µì‚¬
        </button>
      </div>

      <details class="mt-4">
        <summary class="text-xs text-gray-400 cursor-pointer hover:text-gray-600 transition-colors">JSON ì¶œë ¥ ë³´ê¸°</summary>
        <pre id="json-output" class="mt-2 bg-gray-950 text-claude-300 p-4 rounded-lg overflow-x-auto text-xs font-mono"></pre>
      </details>
    </div>

    <!-- X Draft Review -->
    <div id="x-review-section" class="hidden mt-5 p-4 rounded-xl border border-gray-200 dark:border-gray-800 bg-white dark:bg-anthro-darkSurface">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-200">X ê²Œì‹œ ì „ draft ê²€í† </h3>
        <span id="x-review-meta" class="text-xs text-gray-400"></span>
      </div>

      <div class="space-y-3">
        <div class="p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid">
          <div class="flex items-center justify-between mb-1">
            <label class="block text-xs text-gray-500">Main post</label>
            <div class="flex items-center gap-1.5">
              <button id="x-copy-main-btn" class="text-xs px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 text-gray-500 hover:border-claude-400 inline-flex items-center gap-1" title="main ë³µì‚¬">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16h8m-8-4h8m2 8H6a2 2 0 01-2-2V6a2 2 0 012-2h8l6 6v8a2 2 0 01-2 2z"/></svg>
                ë³µì‚¬
              </button>
              <button id="x-main-approve-btn" class="text-xs px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 text-gray-500 hover:border-claude-400">main ìŠ¹ì¸</button>
            </div>
          </div>
          <textarea id="x-main-input" rows="4" class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500"></textarea>
          <div id="x-main-count" class="mt-1 text-xs text-gray-400 font-mono">0/280</div>
        </div>
        <div class="p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid">
          <div class="flex items-center justify-between mb-1">
            <label class="block text-xs text-gray-500">Replies</label>
            <div class="flex items-center gap-1.5">
              <button id="x-copy-replies-btn" class="text-xs px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 text-gray-500 hover:border-claude-400 inline-flex items-center gap-1" title="replies ë³µì‚¬">
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16h8m-8-4h8m2 8H6a2 2 0 01-2-2V6a2 2 0 012-2h8l6 6v8a2 2 0 01-2 2z"/></svg>
                ë³µì‚¬
              </button>
              <button id="x-replies-approve-btn" class="text-xs px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 text-gray-500 hover:border-claude-400">replies ìŠ¹ì¸</button>
            </div>
          </div>
          <div id="x-replies-editor" class="space-y-2"></div>
        </div>
      </div>

      <details class="mt-4 p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid">
        <summary class="text-sm font-semibold text-gray-700 dark:text-gray-200 cursor-pointer">AIë¡œ í…ìŠ¤íŠ¸ ë‹¤ë“¬ê¸°</summary>
        <div class="mt-3 space-y-3">
          <div class="p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-anthro-darkSurface">
            <label class="block text-xs text-gray-500 mb-1">Main instruction</label>
            <textarea id="x-ai-main-instruction" rows="2" placeholder="ì˜ˆ: mainì„ ë” ê°„ê²°í•˜ê³  ì„íŒ©íŠ¸ ìˆê²Œ ì •ë¦¬í•´ì¤˜."
              class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500"></textarea>
            <div class="mt-2">
              <button id="x-ai-main-rewrite-btn" class="px-3 py-1.5 rounded-md border border-gray-200 dark:border-gray-700 text-xs text-gray-600 dark:text-gray-300 hover:border-claude-400 transition-all">mainë§Œ AI ìˆ˜ì •</button>
            </div>
          </div>
          <div class="p-3 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-anthro-darkSurface">
            <div class="flex items-center gap-2 mb-1">
              <label class="text-xs text-gray-500">Reply target</label>
              <select id="x-ai-reply-target" class="px-2 py-1 rounded-md border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-xs">
                <option value="all">ì „ì²´ replies</option>
              </select>
            </div>
            <textarea id="x-ai-reply-instruction" rows="2" placeholder="ì˜ˆ: reply 2ëŠ” ì‹¤ë¬´ ì ìš© ê´€ì ìœ¼ë¡œ ë‹¤ì‹œ ì¨ì¤˜."
              class="w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500"></textarea>
            <div class="mt-2">
              <button id="x-ai-reply-rewrite-btn" class="px-3 py-1.5 rounded-md border border-gray-200 dark:border-gray-700 text-xs text-gray-600 dark:text-gray-300 hover:border-claude-400 transition-all">reply AI ìˆ˜ì •</button>
            </div>
          </div>
        </div>
        <div class="mt-2 text-xs text-gray-400" id="x-ai-status"></div>
        <div id="x-ai-history" class="mt-2 space-y-1 text-xs text-gray-500 dark:text-gray-400"></div>
      </details>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="x-approve-post-btn" class="px-4 py-2 rounded-lg bg-claude-500 text-white text-sm font-semibold hover:bg-claude-600 transition-all inline-flex items-center gap-2">
          <svg id="x-post-spinner" class="hidden w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
          </svg>
          <span id="x-post-btn-label">X ê²Œì‹œ</span>
        </button>
        <button id="x-approve-all-btn" class="px-4 py-2 rounded-lg border border-gray-200 dark:border-gray-700 text-sm font-semibold text-gray-700 dark:text-gray-200 hover:border-claude-400 transition-all">ì „ì²´ ìŠ¹ì¸</button>
        <button id="x-copy-thread-btn" class="px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-300 hover:border-claude-400 transition-all">ìŠ¤ë ˆë“œ ë³µì‚¬</button>
      </div>
      <div id="x-review-note" class="mt-2 text-xs text-gray-400"></div>
    </div>

    <!-- Submit Status (outside preview-section so it stays visible after submit clears items) -->
    <div id="submit-status" class="hidden mt-3 p-4 rounded-xl text-sm"></div>

    <!-- Confirm Modal -->
    <div id="confirm-modal" class="hidden fixed inset-0 z-50">
      <div id="confirm-backdrop" class="absolute inset-0 bg-black/40 animate-fade-in"></div>
      <div class="flex items-center justify-center min-h-full p-4">
        <div class="animate-fade-in-up relative max-w-md w-full bg-white dark:bg-anthro-darkSurface rounded-2xl border border-gray-200 dark:border-gray-800 shadow-xl p-6">
          <h3 class="text-lg font-bold text-gray-900 dark:text-gray-100 mb-3">í•­ëª© ì¶”ê°€ í™•ì¸</h3>
          <p id="confirm-message" class="text-sm text-gray-600 dark:text-gray-300 mb-2"></p>
          <div id="confirm-item-list" class="mb-3 max-h-40 overflow-y-auto text-xs text-gray-500 dark:text-gray-400 space-y-1"></div>
          <div class="border-t border-gray-200 dark:border-gray-700 my-3"></div>
          <label class="mb-4 flex items-start gap-2 text-xs text-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-anthro-darkMid px-3 py-2 rounded-lg">
            <input type="checkbox" id="confirm-manual-approval" class="mt-0.5 accent-claude-500" checked />
            <span>X ê²Œì‹œ ì „ì— draftë¥¼ í™•ì¸í•˜ê³  ì§ì ‘ ìŠ¹ì¸í• ê²Œìš”</span>
          </label>
          <div class="flex gap-2">
            <button id="confirm-cancel" class="flex-1 px-4 py-2.5 rounded-lg border border-gray-200 dark:border-gray-700 text-sm text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-all">ì·¨ì†Œ</button>
            <button id="confirm-submit" class="flex-1 px-4 py-2.5 rounded-lg bg-claude-500 text-white text-sm font-semibold hover:bg-claude-600 transition-all">í™•ì¸</button>
          </div>
        </div>
      </div>
    </div>
  </section>
</Layout>

<script>
  // â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let parsedItems: any[] = [];
  let selectedType = 'paper';
  let pendingSubmitItems: any[] = [];
  let submittedIds = new Set<string>();
  let existingIds = new Set<string>();  // IDs already committed to items.json
  let hasActiveWorkflowTracking = false;
  let requireManualApprovalForCurrentSubmit = true;
  let currentCommittedSha = '';
  let currentRepoForSubmit = '';
  let xDraftData: {
    commitSha: string;
    thread: { main: string; replies: string[] };
    meta?: Record<string, any>;
  } | null = null;
  let xMainApproved = false;
  let xRepliesApproved = false;
  let xAiHistory: Array<{ at: string; target: string; instruction: string; model: string; summary: string }> = [];
  let isPostingInProgress = false;
  let isAiRewriteInProgress = false;

  const WORKFLOW_TRACKING_KEY = 'nlp_paper_news_admin_workflow_tracking_v1';
  const MOCK_MODE_KEY = 'nlp_paper_news_admin_mock_mode_v1';
  const X_HARD_LIMIT = 280;
  const URL_REGEX = /https?:\/\/[^\s)]+/gi;

  const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  function isLocalDevHost() {
    const host = window.location.hostname;
    return host === 'localhost' || host === '127.0.0.1' || host === '::1';
  }

  function isMockMode() {
    return isLocalDevHost() && localStorage.getItem(MOCK_MODE_KEY) === 'true';
  }

  function setMockMode(enabled: boolean) {
    if (!isLocalDevHost()) {
      localStorage.removeItem(MOCK_MODE_KEY);
      return;
    }
    localStorage.setItem(MOCK_MODE_KEY, enabled ? 'true' : 'false');
  }

  function utf8ToBase64(str: string) {
    return btoa(unescape(encodeURIComponent(str)));
  }

  function base64ToUtf8(str: string) {
    return decodeURIComponent(escape(atob(str)));
  }

  function countXChars(text: string) {
    const normalized = String(text || '').replace(URL_REGEX, 'x'.repeat(23));
    const codepoint = Array.from(normalized).length;
    try {
      const seg = new Intl.Segmenter(undefined, { granularity: 'grapheme' });
      const grapheme = Array.from(seg.segment(normalized)).length;
      return Math.max(codepoint, grapheme);
    } catch {
      return codepoint;
    }
  }

  // â”€â”€â”€ Type colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const TYPE_COLORS: Record<string, { border: string; bg: string; text: string }> = {
    paper: { border: 'border-claude-400', bg: 'bg-claude-50 dark:bg-claude-950/20', text: 'text-claude-700 dark:text-claude-300' },
    dev: { border: 'border-anthro-green-500', bg: 'bg-anthro-green-200/30 dark:bg-anthro-green-800/20', text: 'text-anthro-green-700 dark:text-anthro-green-300' },
    news: { border: 'border-anthro-blue-500', bg: 'bg-anthro-blue-200/30 dark:bg-anthro-blue-800/20', text: 'text-anthro-blue-700 dark:text-anthro-blue-300' },
  };

  const TYPE_ICONS: Record<string, string> = { paper: 'ğŸ“œ', dev: 'ğŸ§‘ğŸ»â€ğŸ’»', news: 'ğŸ—ï¸' };

  const TYPE_MAP: Record<string, string> = {
    'ğŸ“œ': 'paper', 'ğŸ§‘ğŸ»â€ğŸ’»': 'dev', 'ğŸ§‘ğŸ»ğŸ’»': 'dev', 'ğŸ—ï¸': 'news', 'ğŸ—': 'news',
  };

  // â”€â”€â”€ Load existing IDs from GitHub â”€â”€â”€â”€â”€
  async function loadExistingIds() {
    const token = localStorage.getItem('github_token');
    if (!token) return;
    const repo = (document.getElementById('github-repo') as HTMLInputElement)?.value || 'chanmuzi/NLP-Paper-News';
    try {
      const getRes = await fetch(`https://api.github.com/repos/${repo}/contents/data/items.json`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      if (!getRes.ok) return;
      const fileData = await getRes.json();

      let base64Content: string;
      if (fileData.content) {
        base64Content = fileData.content.replace(/\n/g, '');
      } else {
        const blobRes = await fetch(`https://api.github.com/repos/${repo}/git/blobs/${fileData.sha}`, {
          headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
        });
        if (!blobRes.ok) return;
        const blobData = await blobRes.json();
        base64Content = blobData.content.replace(/\n/g, '');
      }
      const binaryStr = atob(base64Content);
      const bytes = new Uint8Array(binaryStr.length);
      for (let i = 0; i < binaryStr.length; i++) {
        bytes[i] = binaryStr.charCodeAt(i);
      }
      const rawContent = new TextDecoder('utf-8').decode(bytes);
      const data = JSON.parse(rawContent);
      existingIds = new Set((data.items || []).map((i: any) => i.id));
    } catch { /* silently fail â€” graceful degradation */ }
  }

  // â”€â”€â”€ Tab switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const tabSimple = document.getElementById('tab-simple')!;
  const tabMarkdown = document.getElementById('tab-markdown')!;
  const panelSimple = document.getElementById('panel-simple')!;
  const panelMarkdown = document.getElementById('panel-markdown')!;

  function switchTab(tab: 'simple' | 'markdown') {
    if (tab === 'simple') {
      tabSimple.classList.add('bg-white', 'dark:bg-anthro-darkSurface', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
      tabSimple.classList.remove('text-gray-500', 'dark:text-gray-400');
      tabMarkdown.classList.remove('bg-white', 'dark:bg-anthro-darkSurface', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
      tabMarkdown.classList.add('text-gray-500', 'dark:text-gray-400');
      panelSimple.classList.remove('hidden');
      panelMarkdown.classList.add('hidden');
    } else {
      tabMarkdown.classList.add('bg-white', 'dark:bg-anthro-darkSurface', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
      tabMarkdown.classList.remove('text-gray-500', 'dark:text-gray-400');
      tabSimple.classList.remove('bg-white', 'dark:bg-anthro-darkSurface', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
      tabSimple.classList.add('text-gray-500', 'dark:text-gray-400');
      panelMarkdown.classList.remove('hidden');
      panelSimple.classList.add('hidden');
    }
  }

  tabSimple.addEventListener('click', () => switchTab('simple'));
  tabMarkdown.addEventListener('click', () => switchTab('markdown'));

  // â”€â”€â”€ Type selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.querySelectorAll('.type-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const type = (btn as HTMLElement).dataset.type || 'paper';
      selectedType = type;
      const colors = TYPE_COLORS[type];

      document.querySelectorAll('.type-btn').forEach(b => {
        b.classList.remove('border-claude-400', 'bg-claude-50', 'dark:bg-claude-950/20', 'text-claude-700', 'dark:text-claude-300');
        b.classList.remove('border-anthro-green-500', 'bg-anthro-green-200/30', 'dark:bg-anthro-green-800/20', 'text-anthro-green-700', 'dark:text-anthro-green-300');
        b.classList.remove('border-anthro-blue-500', 'bg-anthro-blue-200/30', 'dark:bg-anthro-blue-800/20', 'text-anthro-blue-700', 'dark:text-anthro-blue-300');
        b.classList.add('border-gray-200', 'dark:border-gray-700', 'text-gray-500', 'dark:text-gray-400');
        b.classList.remove('active');
      });

      btn.classList.remove('border-gray-200', 'dark:border-gray-700', 'text-gray-500', 'dark:text-gray-400');
      btn.classList.add(...colors.border.split(' '), ...colors.bg.split(' '), ...colors.text.split(' '));
      btn.classList.add('active');
    });
  });

  // â”€â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function getDateValues() {
    return {
      year: (document.getElementById('input-year') as HTMLInputElement).value,
      month: (document.getElementById('input-month') as HTMLInputElement).value,
      week: (document.getElementById('input-week') as HTMLInputElement).value,
    };
  }

  function makeId(org: string, title: string) {
    return `${org}-${title}`
      .toLowerCase()
      .replace(/[^a-z0-9ê°€-í£\s-]/g, '')
      .replace(/\s+/g, '-')
      .slice(0, 100);
  }

  function parseBulletsText(text: string): { text: string; level: number }[] {
    if (!text.trim()) return [];
    return text.split('\n').filter(l => l.trim()).map(line => {
      const leadingSpaces = line.match(/^(\s*)/)?.[1]?.length || 0;
      const hasTabs = line.match(/^\t/);
      const level = hasTabs ? 2 : (leadingSpaces >= 4 ? 2 : leadingSpaces >= 8 ? 3 : 1);
      return { text: line.trim(), level };
    });
  }

  function escapeHtml(s: string) {
    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  function getLocalDuplicateCount(items: any[]) {
    const ids = new Set<string>();
    let duplicateCount = 0;
    for (const item of items) {
      if (ids.has(item.id)) duplicateCount++;
      ids.add(item.id);
    }
    return duplicateCount;
  }

  function setSubmitLoading(isLoading: boolean) {
    const submitBtn = document.getElementById('submit-btn') as HTMLButtonElement | null;
    if (!submitBtn) return;
    const label = document.getElementById('submit-btn-label');
    const icon = submitBtn.querySelector('.submit-icon');
    const spinner = submitBtn.querySelector('.submit-spinner');
    submitBtn.disabled = isLoading;
    if (label) label.textContent = isLoading ? 'ì²˜ë¦¬ì¤‘...' : 'í™•ì¸í•˜ê³  ì¶”ê°€';
    if (icon) icon.classList.toggle('hidden', isLoading);
    if (spinner) spinner.classList.toggle('hidden', !isLoading);
  }

  function clearInputFields() {
    (document.getElementById('markdown-input') as HTMLTextAreaElement).value = '';
    (document.getElementById('simple-org') as HTMLInputElement).value = '';
    (document.getElementById('simple-title') as HTMLInputElement).value = '';
    (document.getElementById('simple-url') as HTMLInputElement).value = '';
    (document.getElementById('simple-bullets') as HTMLTextAreaElement).value = '';
    document.getElementById('parse-errors')?.classList.add('hidden');
    document.getElementById('parse-summary')?.classList.add('hidden');
  }

  // â”€â”€â”€ Simple Mode: Add â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('simple-add-btn')?.addEventListener('click', () => {
    const org = (document.getElementById('simple-org') as HTMLInputElement).value.trim();
    const title = (document.getElementById('simple-title') as HTMLInputElement).value.trim();
    const url = (document.getElementById('simple-url') as HTMLInputElement).value.trim();
    const bulletsText = (document.getElementById('simple-bullets') as HTMLTextAreaElement).value;

    if (!org || !title) {
      showToast('ê¸°ê´€ëª…ê³¼ ì œëª©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.');
      return;
    }

    const { year, month, week } = getDateValues();
    const item = {
      id: makeId(org, title),
      type: selectedType,
      org, title, url,
      date: `${year}-${month.padStart(2, '0')}-W${week.padStart(2, '0')}`,
      year, month, week,
      bullets: parseBulletsText(bulletsText),
      tags: [],
    };

    parsedItems.push(item);
    renderPreview();
    showToast('í•­ëª©ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤');

    // Clear simple fields (keep org and type)
    (document.getElementById('simple-title') as HTMLInputElement).value = '';
    (document.getElementById('simple-url') as HTMLInputElement).value = '';
    (document.getElementById('simple-bullets') as HTMLTextAreaElement).value = '';
  });

  // â”€â”€â”€ Markdown Parser (improved) â”€â”€â”€â”€â”€â”€â”€â”€
  function parseMarkdownItems(text: string, year: string, month: string, week: string, fallbackType: string): { items: any[]; errors: string[] } {
    const lines = text.split('\n');
    const items: any[] = [];
    const errors: string[] = [];
    let currentItem: any = null;
    let lineNum = 0;

    for (const line of lines) {
      lineNum++;
      if (!line.trim()) continue;

      // Match line starting with "- " (with optional emoji)
      const iconMatch = line.match(/^-\s*(ğŸ“œ|ğŸ§‘ğŸ»â€ğŸ’»|ğŸ§‘ğŸ»ğŸ’»|ğŸ—ï¸|ğŸ—)\s*/);
      const plainMatch = !iconMatch && line.match(/^-\s+\[/);

      if (iconMatch || plainMatch) {
        if (currentItem) items.push(currentItem);

        let type = fallbackType;
        let rest = '';

        if (iconMatch) {
          type = TYPE_MAP[iconMatch[1]] || fallbackType;
          rest = line.slice(iconMatch[0].length).trim();
        } else {
          // Plain format: - [Org] [Title](URL)
          rest = line.replace(/^-\s+/, '').trim();
        }

        // Parse first bracket [...]
        const firstBracket = rest.match(/^\[([^\]]+)\]/);
        if (!firstBracket) {
          errors.push(`${lineNum}í–‰: [ê¸°ê´€ëª…] ë˜ëŠ” [ì œëª©] í˜•ì‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`);
          currentItem = null;
          continue;
        }

        const firstContent = firstBracket[1];
        const afterFirst = rest.slice(firstBracket[0].length);

        let org = '';
        let title = '';
        let url = '';

        if (afterFirst.match(/^\s*\[/)) {
          // [Org] [Title](URL) or [Org] [Title]
          org = firstContent;
          const titlePart = afterFirst.trimStart();
          let bracketCount = 0;
          let titleEnd = -1;
          for (let i = 0; i < titlePart.length; i++) {
            if (titlePart[i] === '[') bracketCount++;
            else if (titlePart[i] === ']') {
              bracketCount--;
              if (bracketCount === 0) { titleEnd = i; break; }
            }
          }
          if (titleEnd > 0) {
            title = titlePart.slice(1, titleEnd).replace(/\*\*/g, '').trim();
            const afterTitle = titlePart.slice(titleEnd + 1).trim();
            const urlMatch = afterTitle.match(/^\(([^)]+)\)/);
            if (urlMatch) url = urlMatch[1];
          }
        } else if (afterFirst.match(/^\(/)) {
          // [Title](URL) â€” org ìƒëµ, ë§ˆí¬ë‹¤ìš´ ë§í¬
          title = firstContent.replace(/\*\*/g, '').trim();
          org = title;
          const urlMatch = afterFirst.match(/^\(([^)]+)\)/);
          if (urlMatch) url = urlMatch[1];
        } else if (afterFirst.trim()) {
          // [Org] plain text title
          org = firstContent;
          title = afterFirst.replace(/\*\*/g, '').trim();
        } else {
          // [Title] only
          title = firstContent.replace(/\*\*/g, '').trim();
          org = title;
        }

        if (!title) {
          errors.push(`${lineNum}í–‰: ì œëª©ì„ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤`);
          currentItem = null;
          continue;
        }

        currentItem = {
          id: makeId(org, title),
          type, org, title, url,
          date: `${year}-${month.padStart(2, '0')}-W${week.padStart(2, '0')}`,
          year, month, week,
          bullets: [], tags: [],
        };
        continue;
      }

      // Bullet lines: any indented line starting with -
      if (currentItem && line.match(/^[\s\t]+-/)) {
        const match = line.match(/^([\s\t]*)-\s+(.+)$/);
        if (match) {
          const rawIndent = match[1];
          const bulletText = match[2].trim();
          // Support both tabs and spaces
          const tabCount = (rawIndent.match(/\t/g) || []).length;
          const spaceCount = rawIndent.replace(/\t/g, '').length;
          const effectiveIndent = tabCount * 4 + spaceCount;
          const level = effectiveIndent < 6 ? 1 : effectiveIndent < 12 ? 2 : 3;
          currentItem.bullets.push({ text: bulletText, level });
        }
      } else if (currentItem && line.match(/^\s+[^-\s]/)) {
        // Continuation line (indented but no dash) - treat as bullet
        const text = line.trim();
        if (text) {
          const rawIndent = line.match(/^(\s*)/)?.[1] || '';
          const level = rawIndent.length >= 8 ? 2 : 1;
          currentItem.bullets.push({ text, level });
        }
      }
    }

    if (currentItem) items.push(currentItem);

    if (items.length === 0 && errors.length === 0) {
      errors.push('íŒŒì‹±ëœ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. "- [ê¸°ê´€ëª…] [ì œëª©](URL)" ë˜ëŠ” "- [ì œëª©](URL)" í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”.');
    }

    return { items, errors };
  }

  // â”€â”€â”€ Parse button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('parse-btn')?.addEventListener('click', () => {
    const textarea = document.getElementById('markdown-input') as HTMLTextAreaElement;
    const fallbackType = (document.getElementById('md-fallback-type') as HTMLSelectElement).value;
    const { year, month, week } = getDateValues();
    const errorsEl = document.getElementById('parse-errors')!;
    const summaryEl = document.getElementById('parse-summary')!;

    const result = parseMarkdownItems(textarea.value, year, month, week, fallbackType);

    if (result.errors.length > 0) {
      errorsEl.innerHTML = result.errors.map(e => `<div>âš ï¸ ${escapeHtml(e)}</div>`).join('');
      errorsEl.classList.remove('hidden');
    } else {
      errorsEl.classList.add('hidden');
    }

    if (result.items.length > 0) {
      parsedItems = result.items;
      renderPreview();
      const localDuplicateCount = getLocalDuplicateCount(result.items);
      const alreadySubmitted = result.items.filter(i => submittedIds.has(i.id));
      const alreadySubmittedIdSet = new Set(alreadySubmitted.map((i) => i.id));
      const alreadyCommitted = result.items.filter(i => existingIds.has(i.id) && !alreadySubmittedIdSet.has(i.id));
      const realNewCount = result.items.filter(i => !submittedIds.has(i.id) && !existingIds.has(i.id)).length;
      let summaryHtml = `
        <div class="font-semibold text-gray-700 dark:text-gray-200 mb-1">íŒŒì‹± í…ŒìŠ¤íŠ¸ ì™„ë£Œ</div>
        <div>ì¶”ê°€ í›„ë³´: <span class="font-mono font-semibold">${realNewCount}</span>ê±´${alreadyCommitted.length > 0 ? ` <span class="text-gray-400">(ì´ë¯¸ ì»¤ë°‹ë¨: ${alreadyCommitted.length}ê±´)</span>` : ''}</div>
        <div>í˜•ì‹ ì˜¤ë¥˜: <span class="font-mono font-semibold">${result.errors.length}</span>ê±´</div>
        <div>ì…ë ¥ ë‚´ë¶€ ì¤‘ë³µ(id): <span class="font-mono font-semibold">${localDuplicateCount}</span>ê±´</div>
      `;
      if (alreadyCommitted.length > 0) {
        summaryHtml += `<div class="mt-1 text-amber-600 dark:text-amber-400 font-semibold">ì´ë¯¸ ì»¤ë°‹ëœ í•­ëª© ${alreadyCommitted.length}ê±´ í¬í•¨ â€” ë¯¸ë¦¬ë³´ê¸°ì—ì„œ ì œê±°í•˜ê±°ë‚˜ ê·¸ëŒ€ë¡œ ë‘ë©´ ìë™ ê±´ë„ˆëœë‹ˆë‹¤</div>`;
      }
      if (alreadySubmitted.length > 0) {
        summaryHtml += `<div class="mt-1 text-red-600 dark:text-red-400 font-semibold">ì´ë¯¸ ì œì¶œëœ í•­ëª© ${alreadySubmitted.length}ê±´ í¬í•¨ â€” ë¯¸ë¦¬ë³´ê¸°ì—ì„œ ì¤‘ë³µ í•­ëª©ì„ ì œê±°í•´ì•¼ ì œì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</div>`;
      }
      summaryEl.innerHTML = summaryHtml;
      summaryEl.classList.remove('hidden');
      showToast(`${result.items.length}ê°œ í•­ëª©ì´ íŒŒì‹±ë˜ì—ˆìŠµë‹ˆë‹¤`);
    } else {
      summaryEl.classList.add('hidden');
    }
  });

  document.getElementById('clear-md-btn')?.addEventListener('click', () => {
    (document.getElementById('markdown-input') as HTMLTextAreaElement).value = '';
    document.getElementById('parse-errors')?.classList.add('hidden');
    document.getElementById('parse-summary')?.classList.add('hidden');
  });

  // â”€â”€â”€ Preview rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderPreview() {
    const container = document.getElementById('preview-container')!;
    const section = document.getElementById('preview-section')!;
    const countEl = document.getElementById('preview-count')!;
    const jsonOutput = document.getElementById('json-output');

    if (parsedItems.length === 0) {
      section.classList.add('hidden');
      return;
    }

    section.classList.remove('hidden');
    countEl.textContent = parsedItems.length.toString();

    container.innerHTML = parsedItems.map((item, idx) => {
      const icon = TYPE_ICONS[item.type] || 'ğŸ“œ';
      const colors = TYPE_COLORS[item.type] || TYPE_COLORS.paper;
      const dateDisplay = `${item.year}.${String(item.month).padStart(2, '0')} ${item.week}ì£¼ì°¨`;
      const urlDomain = item.url ? (() => { try { return new URL(item.url).hostname.replace('www.', ''); } catch { return ''; } })() : '';
      const isSessionDup = submittedIds.has(item.id);
      const isExistingDup = existingIds.has(item.id);
      const isDuplicate = isSessionDup || isExistingDup;
      const dupBorder = isDuplicate ? 'border-red-300 dark:border-red-800 opacity-60' : `${colors.border}/30`;
      const dupBadge = isExistingDup
        ? '<span class="text-xs font-semibold text-gray-500 dark:text-gray-400 bg-gray-100 dark:bg-gray-800 px-2 py-0.5 rounded-md">ì»¤ë°‹ ì™„ë£Œ</span>'
        : isSessionDup
        ? '<span class="text-xs font-semibold text-red-500 dark:text-red-400 bg-red-50 dark:bg-red-950/30 px-2 py-0.5 rounded-md">ì¤‘ë³µ</span>'
        : '';
      return `
        <div class="p-4 rounded-xl border ${colors.bg} ${dupBorder} relative group">
          <button class="remove-item absolute top-2 right-2 p-1 rounded-md text-gray-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-all" data-idx="${idx}">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
          </button>
          <div class="flex items-center gap-2 mb-2">
            <span class="text-xs font-bold ${colors.text}">${icon} ${item.type.toUpperCase()}</span>
            <span class="text-xs font-semibold text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-white/10 px-2 py-0.5 rounded-md">${escapeHtml(item.org)}</span>
            ${dupBadge}
            <span class="text-xs text-gray-400 font-mono ml-auto">${dateDisplay}</span>
          </div>
          ${item.url
            ? `<a href="${item.url}" target="_blank" class="block text-[15px] font-bold text-gray-900 dark:text-gray-100 hover:text-claude-600 dark:hover:text-claude-400 transition-colors mb-1.5 leading-snug">${escapeHtml(item.title)} <svg class="inline w-3.5 h-3.5 ml-0.5 opacity-40" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/></svg></a>`
            : `<h3 class="text-[15px] font-bold text-gray-900 dark:text-gray-100 mb-1.5 leading-snug">${escapeHtml(item.title)}</h3>`
          }
          ${urlDomain ? `<span class="text-xs text-gray-400 mb-1 block">${urlDomain}</span>` : ''}
          ${item.bullets.length > 0 ? `
            <ul class="text-sm text-gray-700 dark:text-gray-300 space-y-1 mt-2">
              ${item.bullets.map((b: any) => `
                <li class="${b.level > 1 ? 'ml-4 text-xs text-gray-500' : ''} flex items-start gap-2">
                  <span class="mt-[7px] w-1 h-1 rounded-full bg-gray-400 flex-shrink-0"></span>
                  <span>${escapeHtml(b.text)}</span>
                </li>
              `).join('')}
            </ul>
          ` : ''}
        </div>
      `;
    }).join('');

    // Attach remove handlers
    container.querySelectorAll('.remove-item').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt((btn as HTMLElement).dataset.idx || '0');
        parsedItems.splice(idx, 1);
        renderPreview();
      });
    });

    if (jsonOutput) {
      jsonOutput.textContent = JSON.stringify(parsedItems, null, 2);
    }

    // Disable submit if all items are already submitted duplicates
    updateSubmitBtnState();
  }

  function updateSubmitBtnState() {
    const submitBtn = document.getElementById('submit-btn') as HTMLButtonElement | null;
    const label = document.getElementById('submit-btn-label');
    if (!submitBtn || !label) return;

    const newItems = parsedItems.filter(i => !submittedIds.has(i.id) && !existingIds.has(i.id));
    const duplicateCount = parsedItems.length - newItems.length;

    if (parsedItems.length > 0 && newItems.length === 0) {
      submitBtn.disabled = true;
      label.textContent = `ì œì¶œ ë¶ˆê°€ (${duplicateCount}ê±´ ì¤‘ë³µ)`;
    } else if (duplicateCount > 0) {
      submitBtn.disabled = true;
      label.textContent = `ì œì¶œ ë¶ˆê°€ (${duplicateCount}ê±´ ì¤‘ë³µ í¬í•¨)`;
    } else {
      submitBtn.disabled = false;
      label.textContent = 'í™•ì¸í•˜ê³  ì¶”ê°€';
    }
  }

  function validateThreadLimit(main: string, replies: string[]) {
    const failures: { phase: string; used: number }[] = [];
    const mainChars = countXChars(main);
    if (mainChars > X_HARD_LIMIT) failures.push({ phase: 'main', used: mainChars });
    replies.forEach((r, idx) => {
      const used = countXChars(r);
      if (used > X_HARD_LIMIT) failures.push({ phase: `reply ${idx + 1}`, used });
    });
    return failures;
  }

  function clipToXLimit(text: string, limit = X_HARD_LIMIT) {
    const src = String(text || '');
    if (countXChars(src) <= limit) return src;
    const chars = Array.from(src);
    while (chars.length > 0) {
      const candidate = chars.join('');
      if (countXChars(candidate) <= limit) return candidate;
      chars.pop();
    }
    return '';
  }

  function extractCoreText(base: string) {
    return String(base || '')
      .split('\n')
      .map((s) => s.trim())
      .filter(Boolean)
      .filter((s) => !s.startsWith('http'))
      .slice(0, 2)
      .join(' / ');
  }

  function summarizeInstruction(instruction: string) {
    return instruction
      .replace(/\[target:[^\]]+\]/gi, '')
      .replace(/\s+/g, ' ')
      .trim()
      .slice(0, 34);
  }

  function mockRewriteMain(base: string, instruction: string) {
    const core = extractCoreText(base);
    const intent = summarizeInstruction(instruction);
    const lines = [
      `ğŸ“Œ í•µì‹¬ ì—…ë°ì´íŠ¸`,
      core || 'ì´ë²ˆ ì—…ë°ì´íŠ¸ ìš”ì•½',
      `- ìš”ì²­ ë°˜ì˜: ${intent || 'í†¤/êµ¬ì¡° ì¡°ì •'}`,
    ];
    return clipToXLimit(lines.join('\n'));
  }

  function mockRewriteReply(base: string, instruction: string, idx: number) {
    const core = extractCoreText(base);
    const intent = summarizeInstruction(instruction);
    const lines = [
      `${idx + 1}) ${core || 'ì—…ë°ì´íŠ¸ ìƒì„¸'}`,
      `í¬ì¸íŠ¸: ${intent || 'í•µì‹¬ ì„¤ëª… ë³´ê°•'}`,
    ];
    return clipToXLimit(lines.join('\n'));
  }

  function buildMockDraft(items: any[], commitSha: string) {
    const titles = items.slice(0, 3).map((i) => i.title).join(' Â· ');
    const mainBase = `ğŸ“Œ ì´ë²ˆ ì—…ë°ì´íŠ¸ ${items.length}ê±´\n${titles}${items.length > 3 ? ` ì™¸ ${items.length - 3}ê±´` : ''}`;
    const replies = items.map((item, idx) => {
      const lines = [
        `${idx + 1}) ${item.title}`,
        `- ${item.org}`,
      ];
      if (item.url) lines.push(item.url);
      return clipToXLimit(lines.join('\n'));
    });

    return {
      commitSha,
      thread: {
        main: clipToXLimit(mainBase),
        replies,
      },
      meta: {
        main_model: 'mock-local',
        reply_model: 'mock-local',
      }
    };
  }

  function collectEditedThread() {
    const mainInput = document.getElementById('x-main-input') as HTMLTextAreaElement | null;
    if (!mainInput) return null;
    const replyInputs = [...document.querySelectorAll('.x-reply-input')] as HTMLTextAreaElement[];
    return {
      main: mainInput.value.trim(),
      replies: replyInputs.map((el) => el.value.trim()),
    };
  }

  function bindXCountIndicators() {
    const mainInput = document.getElementById('x-main-input') as HTMLTextAreaElement | null;
    const mainCount = document.getElementById('x-main-count');
    if (mainInput && mainCount) {
      const updateMain = () => {
        const used = countXChars(mainInput.value);
        mainCount.textContent = `${used}/${X_HARD_LIMIT}`;
        mainCount.className = `mt-1 text-xs font-mono ${used > X_HARD_LIMIT ? 'text-red-500' : 'text-gray-400'}`;
        xMainApproved = false;
        updateReviewApprovalUi();
      };
      mainInput.addEventListener('input', updateMain);
      updateMain();
    }

    const replies = [...document.querySelectorAll('.x-reply-input')] as HTMLTextAreaElement[];
    replies.forEach((el) => {
      const countEl = document.getElementById(`x-reply-count-${el.dataset.index}`);
      const update = () => {
        const used = countXChars(el.value);
        if (countEl) {
          countEl.textContent = `${used}/${X_HARD_LIMIT}`;
          countEl.className = `text-xs font-mono ${used > X_HARD_LIMIT ? 'text-red-500' : 'text-gray-400'}`;
        }
        xRepliesApproved = false;
        updateReviewApprovalUi();
      };
      el.addEventListener('input', update);
      update();
    });
  }

  function updateReviewApprovalUi() {
    const mainBtn = document.getElementById('x-main-approve-btn');
    const repliesBtn = document.getElementById('x-replies-approve-btn');
    const allBtn = document.getElementById('x-approve-all-btn') as HTMLButtonElement | null;
    const postBtn = document.getElementById('x-approve-post-btn') as HTMLButtonElement | null;
    const postBtnLabel = document.getElementById('x-post-btn-label');
    const postSpinner = document.getElementById('x-post-spinner');
    const noteEl = document.getElementById('x-review-note');

    if (mainBtn) {
      mainBtn.textContent = xMainApproved ? 'main ìŠ¹ì¸ë¨' : 'main ìŠ¹ì¸';
      mainBtn.className = `text-xs px-2 py-1 rounded-md border ${xMainApproved ? 'border-claude-300 text-claude-600 bg-claude-50 dark:bg-claude-950/20' : 'border-gray-200 dark:border-gray-700 text-gray-500 hover:border-claude-400'}`;
    }
    if (repliesBtn) {
      repliesBtn.textContent = xRepliesApproved ? 'replies ìŠ¹ì¸ë¨' : 'replies ìŠ¹ì¸';
      repliesBtn.className = `text-xs px-2 py-1 rounded-md border ${xRepliesApproved ? 'border-claude-300 text-claude-600 bg-claude-50 dark:bg-claude-950/20' : 'border-gray-200 dark:border-gray-700 text-gray-500 hover:border-claude-400'}`;
    }
    if (allBtn) {
      const allApproved = xMainApproved && xRepliesApproved;
      allBtn.textContent = allApproved ? 'ì „ì²´ ìŠ¹ì¸ í•´ì œ' : 'ì „ì²´ ìŠ¹ì¸';
      allBtn.className = `px-4 py-2 rounded-lg border text-sm font-semibold transition-all ${
        allApproved
          ? 'border-claude-300 text-claude-700 bg-claude-50 dark:bg-claude-950/20'
          : 'border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-200 hover:border-claude-400'
      }`;
      allBtn.disabled = isPostingInProgress;
      allBtn.classList.toggle('opacity-50', isPostingInProgress);
      allBtn.classList.toggle('cursor-not-allowed', isPostingInProgress);
    }

    if (postBtn) {
      const enabled = xMainApproved && xRepliesApproved;
      postBtn.disabled = !enabled || isPostingInProgress;
      postBtn.classList.toggle('opacity-50', !enabled || isPostingInProgress);
      postBtn.classList.toggle('cursor-not-allowed', !enabled || isPostingInProgress);
      postBtn.classList.toggle('animate-pulse', isPostingInProgress);
      if (isPostingInProgress) {
        if (postBtnLabel) postBtnLabel.textContent = 'ê²Œì‹œ ì§„í–‰ ì¤‘...';
        if (postSpinner) postSpinner.classList.remove('hidden');
      } else {
        if (postBtnLabel) postBtnLabel.textContent = 'X ê²Œì‹œ';
        if (postSpinner) postSpinner.classList.add('hidden');
      }
    }
    if (noteEl) {
      noteEl.textContent = (xMainApproved && xRepliesApproved)
        ? 'main/replies ìŠ¹ì¸ ì™„ë£Œ. ì´ì œ ê²Œì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
        : 'ê²Œì‹œ ì „ mainê³¼ repliesë¥¼ ê°ê° ìŠ¹ì¸í•´ ì£¼ì„¸ìš”.';
    }
  }

  function clearXDraftReview() {
    xDraftData = null;
    xMainApproved = false;
    xRepliesApproved = false;
    xAiHistory = [];

    const section = document.getElementById('x-review-section');
    const mainInput = document.getElementById('x-main-input') as HTMLTextAreaElement | null;
    const repliesEditor = document.getElementById('x-replies-editor');
    const metaEl = document.getElementById('x-review-meta');
    const noteEl = document.getElementById('x-review-note');
    const aiMain = document.getElementById('x-ai-main-instruction') as HTMLTextAreaElement | null;
    const aiReply = document.getElementById('x-ai-reply-instruction') as HTMLTextAreaElement | null;
    const aiStatus = document.getElementById('x-ai-status');

    if (mainInput) mainInput.value = '';
    if (repliesEditor) repliesEditor.innerHTML = '';
    if (metaEl) metaEl.textContent = '';
    if (noteEl) noteEl.textContent = '';
    if (aiMain) aiMain.value = '';
    if (aiReply) aiReply.value = '';
    if (aiStatus) aiStatus.textContent = '';

    renderAiHistory();
    updateReviewApprovalUi();
    section?.classList.add('hidden');
  }

  function renderAiHistory() {
    const el = document.getElementById('x-ai-history');
    if (!el) return;
    if (xAiHistory.length === 0) {
      el.innerHTML = '<div class="text-gray-400">AI ìˆ˜ì • ê¸°ë¡ì´ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.</div>';
      return;
    }
    el.innerHTML = xAiHistory.slice().reverse().map((h) => `
      <div class="rounded-md border border-gray-200 dark:border-gray-700 px-2 py-1">
        <div class="text-[11px] text-gray-400">${escapeHtml(h.at)} Â· model ${escapeHtml(h.model)}</div>
        <div>target: ${escapeHtml(h.target)}</div>
        <div>instruction: ${escapeHtml(h.instruction)}</div>
        <div class="text-gray-400">result: ${escapeHtml(h.summary)}</div>
      </div>
    `).join('');
  }

  function showXDraftReview(
    draft: { commitSha: string; thread: { main: string; replies: string[] }; meta?: Record<string, any> },
    opts: { preserveHistory?: boolean } = { preserveHistory: false }
  ) {
    xDraftData = draft;
    const section = document.getElementById('x-review-section');
    const mainInput = document.getElementById('x-main-input') as HTMLTextAreaElement | null;
    const repliesEditor = document.getElementById('x-replies-editor');
    const metaEl = document.getElementById('x-review-meta');
    const noteEl = document.getElementById('x-review-note');
    const replyTarget = document.getElementById('x-ai-reply-target') as HTMLSelectElement | null;

    if (!section || !mainInput || !repliesEditor) return;
    section.classList.remove('hidden');
    mainInput.value = draft.thread.main || '';

    const mainModel = draft.meta?.main_model || '-';
    const replyModel = draft.meta?.reply_model || '-';
    if (metaEl) metaEl.textContent = `main ëª¨ë¸: ${mainModel} Â· reply ëª¨ë¸: ${replyModel}`;
    if (!opts.preserveHistory) xAiHistory = [];
    renderAiHistory();
    xMainApproved = false;
    xRepliesApproved = false;
    if (noteEl) noteEl.textContent = 'í…ìŠ¤íŠ¸ë¥¼ í™•ì¸/ìˆ˜ì •í•˜ê³  ìŠ¹ì¸í•´ ì£¼ì„¸ìš”.';

    repliesEditor.innerHTML = (draft.thread.replies || []).map((reply, idx) => `
      <div>
        <label class="block text-xs text-gray-500 mb-1">Reply ${idx + 1}</label>
        <textarea
          data-index="${idx + 1}"
          class="x-reply-input w-full px-3 py-2 rounded-lg border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-anthro-darkMid text-sm text-gray-900 dark:text-gray-100 outline-none focus:border-claude-500"
          rows="3"
        >${escapeHtml(reply)}</textarea>
        <div id="x-reply-count-${idx + 1}" class="text-xs font-mono text-gray-400">0/280</div>
      </div>
    `).join('');

    if (replyTarget) {
      replyTarget.innerHTML = [
        '<option value="all">ì „ì²´ replies</option>',
        ...(draft.thread.replies || []).map((_: string, idx: number) => `<option value="${idx + 1}">reply ${idx + 1}</option>`)
      ].join('');
    }

    bindXCountIndicators();
    updateReviewApprovalUi();
  }

  // Clear preview
  document.getElementById('clear-preview')?.addEventListener('click', () => {
    parsedItems = [];
    renderPreview();
    document.getElementById('preview-section')?.classList.add('hidden');
  });

  // â”€â”€â”€ GitHub API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function submitToGitHub(items: any[]) {
    const token = localStorage.getItem('github_token');
    const repo = (document.getElementById('github-repo') as HTMLInputElement)?.value || 'chanmuzi/NLP-Paper-News';
    const mockMode = isMockMode();

    if (!token && !mockMode) {
      showStatus('GitHub í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ìƒë‹¨ GitHub ë²„íŠ¼ì—ì„œ í† í°ì„ ì…ë ¥í•˜ì„¸ìš”.', 'error');
      return;
    }

    if (mockMode) {
      setSubmitLoading(true);
      showStatus('1/3 [mock] ì…ë ¥ í•­ëª© ê²€ì¦ ì¤‘...', 'info');
      await sleep(250);

      const newItems = items.filter(i => !submittedIds.has(i.id) && !existingIds.has(i.id));
      const skippedCount = items.length - newItems.length;
      if (newItems.length === 0) {
        showStatus(`[mock] ì¶”ê°€í•  ìƒˆ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ${skippedCount}ê°œ í•­ëª©ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.`, 'warn');
        setSubmitLoading(false);
        return;
      }

      showStatus('2/3 [mock] ì»¤ë°‹ ì‹œë®¬ë ˆì´ì…˜ ì¤‘...', 'info');
      await sleep(350);

      const fakeSha = Math.random().toString(16).slice(2, 9).padEnd(7, '0');
      items.forEach(i => { submittedIds.add(i.id); existingIds.add(i.id); });
      parsedItems = [];
      renderPreview();
      clearInputFields();
      setSubmitLoading(false);

      currentCommittedSha = fakeSha;
      currentRepoForSubmit = repo;
      const draft = buildMockDraft(newItems, fakeSha);
      showXDraftReview(draft);

      if (requireManualApprovalForCurrentSubmit === false) {
        showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${fakeSha}\nìë™ ìŠ¹ì¸ ëª¨ë“œë¡œ X ê²Œì‹œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...`, 'info', { autoScroll: true });
        await runMockPostFlow(fakeSha);
      } else {
        showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${fakeSha}\nX draftê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. draftë¥¼ í™•ì¸í•œ ë’¤ ìŠ¹ì¸í•´ ì£¼ì„¸ìš”.`, 'success', { autoScroll: true });
      }
      return;
    }

    setSubmitLoading(true);
    showStatus('1/4 ê¸°ì¡´ ë°ì´í„° ì¡°íšŒ ì¤‘...', 'info');

    try {
      const getRes = await fetch(`https://api.github.com/repos/${repo}/contents/data/items.json`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });

      if (!getRes.ok) {
        const errText = await getRes.text();
        throw new Error(`GitHub API ì˜¤ë¥˜ (${getRes.status}): ${getRes.statusText}. ${errText}`);
      }

      const fileData = await getRes.json();

      // Decode file content - use Blobs API for large files (>1MB)
      let rawContent: string;
      try {
        let base64Content: string;
        if (fileData.content) {
          // Small file: content available directly from Contents API
          base64Content = fileData.content.replace(/\n/g, '');
        } else {
          // Large file (>1MB): Contents API omits content, use Git Blobs API
          showStatus('1/4 ëŒ€ìš©ëŸ‰ íŒŒì¼ Blob APIë¡œ ì¡°íšŒ ì¤‘...', 'info');
          const blobRes = await fetch(`https://api.github.com/repos/${repo}/git/blobs/${fileData.sha}`, {
            headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
          });
          if (!blobRes.ok) {
            throw new Error(`Blob API ì˜¤ë¥˜ (${blobRes.status}): íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
          }
          const blobData = await blobRes.json();
          base64Content = blobData.content.replace(/\n/g, '');
        }
        const binaryStr = atob(base64Content);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        rawContent = new TextDecoder('utf-8').decode(bytes);
      } catch (e: any) {
        if (e.message.includes('Blob API')) throw e;
        throw new Error('items.json ë””ì½”ë”© ì‹¤íŒ¨. íŒŒì¼ì´ ë„ˆë¬´ í¬ê±°ë‚˜ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
      }

      let currentContent: any;
      try {
        currentContent = JSON.parse(rawContent);
      } catch (e) {
        throw new Error('items.json JSON íŒŒì‹± ì‹¤íŒ¨. íŒŒì¼ í˜•ì‹ì„ í™•ì¸í•˜ì„¸ìš”.');
      }

      showStatus('2/4 ì¤‘ë³µ ê²€ì‚¬ ì¤‘...', 'info');
      const existingIds = new Set(currentContent.items.map((i: any) => i.id));
      const newItems = items.filter(i => !existingIds.has(i.id));
      const skippedCount = items.length - newItems.length;

      if (newItems.length === 0) {
        showStatus(`ì¶”ê°€í•  ìƒˆ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ${skippedCount}ê°œ í•­ëª©ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.`, 'warn');
        return;
      }

      currentContent.items = [...newItems, ...currentContent.items];
      currentContent.total_items = currentContent.items.length;
      currentContent.last_updated = new Date().toISOString();
      currentContent.stats = {
        total: currentContent.items.length,
        paper: currentContent.items.filter((i: any) => i.type === 'paper').length,
        dev: currentContent.items.filter((i: any) => i.type === 'dev').length,
        news: currentContent.items.filter((i: any) => i.type === 'news').length,
      };

      showStatus('3/4 ì»¤ë°‹ ê°ì²´ ìƒì„± ì¤‘...', 'info');

      // Encode with proper UTF-8 handling
      const jsonStr = JSON.stringify(currentContent, null, 2);
      const encoder = new TextEncoder();
      const uint8 = encoder.encode(jsonStr);
      let binary = '';
      for (let i = 0; i < uint8.length; i++) {
        binary += String.fromCharCode(uint8[i]);
      }
      const newBase64 = btoa(binary);

      const titles = newItems.map((i: any) => i.title).slice(0, 3).join(', ');
      const commitMessage = `Add ${newItems.length} item(s): ${titles}`;

      // Use Git Data API for reliable large file commits
      // Step 1: Create a new blob with the updated content
      const blobRes = await fetch(`https://api.github.com/repos/${repo}/git/blobs`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ content: newBase64, encoding: 'base64' }),
      });
      if (!blobRes.ok) {
        const errData = await blobRes.json().catch(() => ({ message: blobRes.statusText }));
        throw new Error(`Blob ìƒì„± ì‹¤íŒ¨ (${blobRes.status}): ${errData.message}`);
      }
      const newBlob = await blobRes.json();

      // Step 2: Get the current branch reference
      const refRes = await fetch(`https://api.github.com/repos/${repo}/git/ref/heads/main`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      if (!refRes.ok) throw new Error('ë¸Œëœì¹˜ ì°¸ì¡°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      const refData = await refRes.json();
      const latestCommitSha = refData.object.sha;

      // Step 3: Get the current commit's tree
      const commitRes = await fetch(`https://api.github.com/repos/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      if (!commitRes.ok) throw new Error('ì»¤ë°‹ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      const commitData = await commitRes.json();

      // Step 4: Create a new tree with the updated file
      const treeRes = await fetch(`https://api.github.com/repos/${repo}/git/trees`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          base_tree: commitData.tree.sha,
          tree: [{ path: 'data/items.json', mode: '100644', type: 'blob', sha: newBlob.sha }],
        }),
      });
      if (!treeRes.ok) throw new Error('íŠ¸ë¦¬ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      const newTree = await treeRes.json();

      // Step 5: Create a new commit
      const newCommitRes = await fetch(`https://api.github.com/repos/${repo}/git/commits`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: commitMessage,
          tree: newTree.sha,
          parents: [latestCommitSha],
        }),
      });
      if (!newCommitRes.ok) throw new Error('ì»¤ë°‹ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      const newCommit = await newCommitRes.json();

      // Step 6: Update the branch reference
      showStatus('4/4 main ë¸Œëœì¹˜ ë°˜ì˜ ì¤‘...', 'info');
      const updateRefRes = await fetch(`https://api.github.com/repos/${repo}/git/refs/heads/main`, {
        method: 'PATCH',
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ sha: newCommit.sha }),
      });
      if (!updateRefRes.ok) {
        const errData = await updateRefRes.json().catch(() => ({ message: updateRefRes.statusText }));
        throw new Error(`ë¸Œëœì¹˜ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (${updateRefRes.status}): ${errData.message}`);
      }

      const skippedMsg = skippedCount > 0 ? ` (${skippedCount}ê°œ ì¤‘ë³µ ê±´ë„ˆëœ€)` : '';
      const shortSha = (newCommit.sha || '').slice(0, 7);
      items.forEach(i => { submittedIds.add(i.id); existingIds.add(i.id); });
      parsedItems = [];
      renderPreview();
      clearInputFields();
      setSubmitLoading(false);

      // Start workflow polling
      showStatus(`ì»¤ë°‹ ì™„ë£Œ${skippedMsg} Â· ${shortSha}\nX draft ìƒì„± ì›Œí¬í”Œë¡œ ëŒ€ê¸° ì¤‘...`, 'info');
      currentCommittedSha = newCommit.sha;
      currentRepoForSubmit = repo;
      startWorkflowTracking(repo, token, newCommit.sha, newItems.length, undefined, requireManualApprovalForCurrentSubmit);
    } catch (err: any) {
      showStatus(`ì˜¤ë¥˜: ${err.message}`, 'error');
      setSubmitLoading(false);
    }
  }

  // â”€â”€â”€ Workflow Polling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let pollTimer: ReturnType<typeof setTimeout> | null = null;
  let pollSessionId = 0;

  type WorkflowTrackingState = {
    repo: string;
    commitSha: string;
    startedAt: number;
    expectedReplies: number;
    requireManualApproval?: boolean;
  };

  type LivePostProgress = {
    postingReply?: number;
    totalReplies?: number;
    postedReplies?: number;
    degraded?: boolean;
  };

  function saveWorkflowTracking(state: WorkflowTrackingState) {
    localStorage.setItem(WORKFLOW_TRACKING_KEY, JSON.stringify(state));
  }

  function loadWorkflowTracking(): WorkflowTrackingState | null {
    try {
      const raw = localStorage.getItem(WORKFLOW_TRACKING_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed?.repo || !parsed?.commitSha || !parsed?.startedAt) return null;
      return {
        repo: String(parsed.repo),
        commitSha: String(parsed.commitSha),
        startedAt: Number(parsed.startedAt),
        expectedReplies: Number(parsed.expectedReplies || 0),
        requireManualApproval: parsed.requireManualApproval !== false,
      };
    } catch {
      return null;
    }
  }

  function clearWorkflowTracking() {
    localStorage.removeItem(WORKFLOW_TRACKING_KEY);
    hasActiveWorkflowTracking = false;
  }

  function startWorkflowTracking(repo: string, token: string, commitSha: string, expectedReplies: number, startedAt?: number, requireManualApproval = true) {
    const state: WorkflowTrackingState = {
      repo,
      commitSha,
      startedAt: startedAt || Date.now(),
      expectedReplies: Math.max(0, expectedReplies || 0),
      requireManualApproval,
    };
    hasActiveWorkflowTracking = true;
    saveWorkflowTracking(state);
    pollWorkflowStatus(repo, token, commitSha, state);
  }

  async function fetchPostJobProgress(repo: string, token: string, jobId: number): Promise<LivePostProgress | null> {
    const res = await fetch(`https://api.github.com/repos/${repo}/actions/jobs/${jobId}/logs`, {
      headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!res.ok) {
      throw new Error(`log-fetch-${res.status}`);
    }

    const text = await res.text();
    if (!text) return null;

    const postingMatches = [...text.matchAll(/Posting reply (\d+)\/(\d+)\.\.\./g)];
    const postedMatches = [...text.matchAll(/Reply (\d+) posted:/g)];
    const totalFromComplete = text.match(/Thread complete: 1 main \+ (\d+) replies/);
    const degraded = /Thread degraded to main-only mode/.test(text);

    const latestPosting = postingMatches.length > 0 ? postingMatches[postingMatches.length - 1] : null;
    const latestPosted = postedMatches.length > 0 ? postedMatches[postedMatches.length - 1] : null;
    const postingReply = latestPosting ? Number(latestPosting[1]) : undefined;
    const totalReplies = latestPosting ? Number(latestPosting[2]) : (totalFromComplete ? Number(totalFromComplete[1]) : undefined);
    const postedReplies = latestPosted ? Number(latestPosted[1]) : undefined;

    return { postingReply, totalReplies, postedReplies, degraded };
  }

  async function fetchPrepareDraftPayload(repo: string, token: string, jobId: number) {
    const res = await fetch(`https://api.github.com/repos/${repo}/actions/jobs/${jobId}/logs`, {
      headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!res.ok) return null;
    const text = await res.text();
    const match = text.match(/X_DRAFT_PAYLOAD_BASE64=([A-Za-z0-9+/=]+)/);
    if (!match?.[1]) return null;
    try {
      return JSON.parse(base64ToUtf8(match[1]));
    } catch {
      return null;
    }
  }

  async function fetchLogPayloadByKey(repo: string, token: string, jobId: number, key: string) {
    const res = await fetch(`https://api.github.com/repos/${repo}/actions/jobs/${jobId}/logs`, {
      headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!res.ok) return null;
    const text = await res.text();
    const regex = new RegExp(`${key}=([A-Za-z0-9+/=]+)`);
    const match = text.match(regex);
    if (!match?.[1]) return null;
    try {
      return JSON.parse(base64ToUtf8(match[1]));
    } catch {
      return null;
    }
  }

  async function dispatchApprovedPost(repo: string, token: string, commitSha: string, approvalMode: 'manual_approved' | 'one_time_auto') {
    const thread = collectEditedThread();
    if (!thread) {
      showStatus('X draftë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.', 'error');
      return false;
    }

    const failures = validateThreadLimit(thread.main, thread.replies);
    if (failures.length > 0) {
      const msg = failures.map((f) => `${f.phase} ${f.used}/${X_HARD_LIMIT}`).join(', ');
      showStatus(`ê¸¸ì´ ì œí•œ ì´ˆê³¼: ${msg}`, 'error', { autoScroll: true });
      return false;
    }

    const body = {
      ref: 'main',
      inputs: {
        commit_sha: commitSha,
        approval_mode: approvalMode,
        thread_json_b64: utf8ToBase64(JSON.stringify(thread)),
      }
    };

    const dispatchRes = await fetch(`https://api.github.com/repos/${repo}/actions/workflows/post-approved.yml/dispatches`, {
      method: 'POST',
      headers: {
        'Authorization': `token ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });

    if (!dispatchRes.ok) {
      const err = await dispatchRes.text();
      if (dispatchRes.status === 404) throw new Error('ìŠ¹ì¸ ê²Œì‹œ ì›Œí¬í”Œë¡œìš°ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë¸Œëœì¹˜/íŒŒì¼ ìƒíƒœë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.');
      if (dispatchRes.status === 403) throw new Error('workflow ì‹¤í–‰ ê¶Œí•œì´ ë¶€ì¡±í•©ë‹ˆë‹¤. í† í° scopeë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš” (repo/workflow).');
      throw new Error(`ìŠ¹ì¸ ê²Œì‹œ ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹¤íŒ¨ (${dispatchRes.status}): ${err}`);
    }
    return true;
  }

  async function dispatchRewriteDraft(repo: string, token: string, commitSha: string, instruction: string) {
    const thread = collectEditedThread();
    if (!thread) throw new Error('í˜„ì¬ í¸ì§‘ ì¤‘ì¸ threadë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');

    const dispatchRes = await fetch(`https://api.github.com/repos/${repo}/actions/workflows/rewrite-x-draft.yml/dispatches`, {
      method: 'POST',
      headers: {
        'Authorization': `token ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        ref: 'main',
        inputs: {
          commit_sha: commitSha,
          instruction,
          current_thread_json_b64: utf8ToBase64(JSON.stringify(thread)),
        }
      }),
    });
    if (!dispatchRes.ok) {
      const err = await dispatchRes.text();
      if (dispatchRes.status === 404) throw new Error('AI ìˆ˜ì • ì›Œí¬í”Œë¡œìš°ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë¸Œëœì¹˜/íŒŒì¼ ìƒíƒœë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.');
      if (dispatchRes.status === 403) throw new Error('AI ìˆ˜ì • ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ê¶Œí•œì´ ë¶€ì¡±í•©ë‹ˆë‹¤. í† í° scopeë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš” (repo/workflow).');
      throw new Error(`AI ìˆ˜ì • ì›Œí¬í”Œë¡œìš° ì‹¤í–‰ ì‹¤íŒ¨ (${dispatchRes.status}): ${err}`);
    }
  }

  async function pollRewriteDraftStatus(repo: string, token: string, dispatchedAt: number) {
    const POLL_INTERVAL = 5000;
    const MAX_POLLS = 72;
    let polls = 0;

    const findRun = async () => {
      const res = await fetch(`https://api.github.com/repos/${repo}/actions/workflows/rewrite-x-draft.yml/runs?per_page=10`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      if (!res.ok) return null;
      const data = await res.json();
      return (data.workflow_runs || []).find((r: any) => Date.parse(r.created_at || '') >= dispatchedAt);
    };

    const findJob = async (runId: number) => {
      const res = await fetch(`https://api.github.com/repos/${repo}/actions/runs/${runId}/jobs`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      if (!res.ok) return null;
      const data = await res.json();
      return (data.jobs || []).find((j: any) => j.name === 'rewrite');
    };

    return new Promise<any>((resolve) => {
      const tick = async () => {
        polls++;
        if (polls > MAX_POLLS) return resolve(null);
        const run = await findRun();
        if (!run) return setTimeout(tick, POLL_INTERVAL);
        if (run.status !== 'completed') return setTimeout(tick, POLL_INTERVAL);
        const job = await findJob(run.id);
        if (!job?.id) return resolve(null);
        const payload = await fetchLogPayloadByKey(repo, token, job.id, 'REWRITE_RESULT_BASE64');
        resolve({ run, payload });
      };
      tick();
    });
  }

  async function pollWorkflowStatus(repo: string, token: string, commitSha: string, state?: WorkflowTrackingState) {
    const shortSha = commitSha.slice(0, 7);
    const POLL_INTERVAL = 5000;
    const MAX_POLLS = 96; // 8min max
    const trackingState: WorkflowTrackingState = state || {
      repo,
      commitSha,
      startedAt: Date.now(),
      expectedReplies: 0,
    };

    if (pollTimer) {
      clearTimeout(pollTimer);
      pollTimer = null;
    }
    pollSessionId += 1;
    const currentSession = pollSessionId;

    let polls = 0;
    const elapsedSeconds = () => Math.max(0, Math.floor((Date.now() - trackingState.startedAt) / 1000));
    const isCurrentSession = () => currentSession === pollSessionId;
    const scheduleNext = () => {
      if (!isCurrentSession()) return;
      pollTimer = setTimeout(poll, POLL_INTERVAL);
    };

    async function ghApi(endpoint: string) {
      const res = await fetch(`https://api.github.com/repos/${repo}/actions/${endpoint}`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      const status = res.status;
      let data: any = null;
      try {
        data = await res.json();
      } catch {
        data = null;
      }
      return { ok: res.ok, status, data };
    }

    async function poll() {
      if (!isCurrentSession()) return;
      polls++;

      if (polls > MAX_POLLS) {
        clearWorkflowTracking();
        showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nì›Œí¬í”Œë¡œ ìƒíƒœ í™•ì¸ ì‹œê°„ ì´ˆê³¼ â€” Actions í˜ì´ì§€ì—ì„œ ì§ì ‘ í™•ì¸í•˜ì„¸ìš”.`, 'warn');
        return;
      }

      if (polls % 6 === 0) {
        saveWorkflowTracking(trackingState);
      }

      try {
        const bySha = await ghApi(`runs?head_sha=${commitSha}&per_page=5`);

        if (!bySha.ok && [401, 403].includes(bySha.status)) {
          clearWorkflowTracking();
          showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nì›Œí¬í”Œë¡œ ìƒíƒœ ì¡°íšŒ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. í† í° scope(repo/workflow)ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.`, 'error');
          return;
        }

        // head_sha ì¡°íšŒê°€ ë¹„ê±°ë‚˜ ì§€ì—°ë˜ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ workflow ê¸°ì¤€ìœ¼ë¡œ fallback ì¡°íšŒ
        let runs = bySha.data?.workflow_runs || [];
        if (!runs.length) {
          const fallback = await ghApi(`workflows/notify.yml/runs?per_page=20&event=push&branch=main`);
          if (fallback.ok) {
            const candidates = fallback.data?.workflow_runs || [];
            runs = candidates.filter((r: any) => {
              const created = Date.parse(r.created_at || '');
              const startedAt = Number(trackingState.startedAt || 0);
              const nearNow = Number.isFinite(created) && created >= (startedAt - 120000);
              return nearNow && (r.head_sha === commitSha || r.name === 'Notify & Post to X');
            });
          }
        }

        if (!runs.length) {
          showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nì›Œí¬í”Œë¡œ íŠ¸ë¦¬ê±° ëŒ€ê¸° ì¤‘... (${elapsedSeconds()}s)`, 'info');
          scheduleNext();
          return;
        }

        const run = runs.find((r: any) => r.head_sha === commitSha) || runs.find((r: any) => r.name === 'Notify & Post to X') || runs[0];
        const runStatus = run.status;
        const runConclusion = run.conclusion;

        if (runStatus === 'completed') {
          clearWorkflowTracking();
          const jobsData = await ghApi(`runs/${run.id}/jobs`);
          const prepareJob = jobsData?.jobs?.find((j: any) => j.name === 'prepare');

          if (runConclusion === 'success') {
            const draftPayload = prepareJob?.id
              ? await fetchPrepareDraftPayload(repo, token, prepareJob.id)
              : null;

            if (draftPayload?.thread?.main) {
              const draft = {
                commitSha,
                thread: {
                  main: String(draftPayload.thread.main || ''),
                  replies: Array.isArray(draftPayload.thread.replies) ? draftPayload.thread.replies.map((x: any) => String(x || '')) : [],
                },
                meta: draftPayload.meta || {},
              };

              currentCommittedSha = commitSha;
              currentRepoForSubmit = repo;
              showXDraftReview(draft);

              if (trackingState.requireManualApproval === false) {
                showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nìë™ ìŠ¹ì¸ ëª¨ë“œë¡œ X ê²Œì‹œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...`, 'info', { autoScroll: true });
                const dispatched = await dispatchApprovedPost(repo, token, commitSha, 'one_time_auto');
                if (!dispatched) return;
                await pollApprovedPostStatus(repo, token, commitSha, Date.now());
              } else {
                showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX draftê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. draftë¥¼ í™•ì¸í•œ ë’¤ ìŠ¹ì¸í•´ ì£¼ì„¸ìš”.`, 'success', { autoScroll: true });
              }
            } else {
              showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX draftë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. Actionsì—ì„œ notify-artifactsë¥¼ í™•ì¸í•˜ì„¸ìš”.`, 'warn');
            }
          } else {
            showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nì›Œí¬í”Œë¡œ ${runConclusion || 'ì‹¤íŒ¨'}`, 'error');
          }
          return;
        }

        const jobsData = await ghApi(`runs/${run.id}/jobs`);
        const jobs = jobsData?.jobs || [];
        const activeJob = jobs.find((j: any) => j.status === 'in_progress');
        const activeStep = activeJob?.steps?.find((s: any) => s.status === 'in_progress');

        let progressMsg = '';
        if (activeJob?.name === 'prepare') {
          progressMsg = 'ë°ì´í„° ì¤€ë¹„ ì¤‘...';
          if (activeStep?.name?.includes('Build digest')) progressMsg = 'í¬ìŠ¤íŠ¸ ìƒì„± ì¤‘...';
          else if (activeStep?.name?.includes('Extract')) progressMsg = 'ìƒˆ í•­ëª© ì¶”ì¶œ ì¤‘...';
        } else if (jobs.every((j: any) => j.status === 'queued')) {
          progressMsg = 'ì›Œí¬í”Œë¡œ ì‹¤í–‰ ëŒ€ê¸° ì¤‘...';
        } else {
          progressMsg = `${runStatus}...`;
        }

        showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\n${progressMsg} (${elapsedSeconds()}s)`, 'info');
        scheduleNext();
      } catch (e) {
        showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nìƒíƒœ ì¬í™•ì¸ ì¤‘... (${elapsedSeconds()}s)`, 'info');
        scheduleNext();
      }
    }

    poll();
  }

  async function pollApprovedPostStatus(repo: string, token: string, commitSha: string, dispatchedAt: number) {
    const shortSha = commitSha.slice(0, 7);
    const POLL_INTERVAL = 5000;
    const MAX_POLLS = 96;
    let polls = 0;
    let liveProgress: LivePostProgress | null = null;
    let lastLogFetchAt = 0;

    async function fetchWorkflowRuns() {
      const res = await fetch(`https://api.github.com/repos/${repo}/actions/workflows/post-approved.yml/runs?per_page=10`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      if (!res.ok) return null;
      return res.json();
    }

    async function fetchJobs(runId: number) {
      const res = await fetch(`https://api.github.com/repos/${repo}/actions/runs/${runId}/jobs`, {
        headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
      });
      if (!res.ok) return null;
      return res.json();
    }

    return new Promise<void>((resolve) => {
      const tick = async () => {
        polls++;
        if (polls > MAX_POLLS) {
          showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nìŠ¹ì¸ ê²Œì‹œ ìƒíƒœ í™•ì¸ ì‹œê°„ ì´ˆê³¼ â€” Actionsì—ì„œ í™•ì¸í•˜ì„¸ìš”.`, 'warn');
          resolve();
          return;
        }

        const runsData = await fetchWorkflowRuns();
        const runs = runsData?.workflow_runs || [];
        const run = runs.find((r: any) => Date.parse(r.created_at || '') >= (dispatchedAt - 30000));
        if (!run) {
          showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nìŠ¹ì¸ ê²Œì‹œ ì›Œí¬í”Œë¡œ ì‹œì‘ ëŒ€ê¸° ì¤‘...`, 'info');
          setTimeout(tick, POLL_INTERVAL);
          return;
        }

        const jobsData = await fetchJobs(run.id);
        const postJob = jobsData?.jobs?.find((j: any) => j.name === 'post_x');

        if (postJob?.status === 'in_progress' && Date.now() - lastLogFetchAt > 10000) {
          lastLogFetchAt = Date.now();
          if (postJob?.id) {
            const progress = await fetchPostJobProgress(repo, token, postJob.id).catch(() => null);
            if (progress) liveProgress = progress;
          }
        }

        if (run.status === 'completed') {
          const postResult = postJob?.id
            ? await fetchLogPayloadByKey(repo, token, postJob.id, 'POST_RESULT_BASE64')
            : null;

          if (run.conclusion === 'success') {
            if (postResult?.degradedMode === 'main_only') {
              showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nmainë§Œ ê²Œì‹œë˜ì—ˆìŠµë‹ˆë‹¤. ë‚¨ì€ repliesëŠ” ìˆ˜ë™ìœ¼ë¡œ ì´ì–´ì„œ ê²Œì‹œí•´ ì£¼ì„¸ìš”.`, 'warn', { autoScroll: true });
              await sleep(4200);
              clearXDraftReview();
              fadeStatusNow();
            } else {
              showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX ê²Œì‹œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success', { autoScroll: true });
              await sleep(4200);
              clearXDraftReview();
              fadeStatusNow();
            }
          } else {
            let guide = 'Actions ë¡œê·¸ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.';
            if (postResult?.errorCode === 'local_length_guard' || postResult?.failurePhase === 'validation') {
              guide = 'ê¸¸ì´ ì œí•œ ì´ˆê³¼ì…ë‹ˆë‹¤. main/replies í…ìŠ¤íŠ¸ë¥¼ ì¤„ì¸ ë’¤ ë‹¤ì‹œ ìŠ¹ì¸í•´ ì£¼ì„¸ìš”.';
            } else if ([403, 429].includes(Number(postResult?.httpStatus))) {
              guide = 'ì •ì±…/ë ˆì´íŠ¸ ì œí•œ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤. ê°™ì€ í…ìŠ¤íŠ¸ ì¬ì‹œë„ ëŒ€ì‹  ìˆ˜ì • í›„ ì¬ê²Œì‹œë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤.';
            } else if (postResult?.errorCode === 'network_error') {
              guide = 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.';
            }
            showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX ê²Œì‹œ ì‹¤íŒ¨\n${guide}`, 'error', { autoScroll: true });
          }
          resolve();
          return;
        }

        if (liveProgress?.postingReply && liveProgress?.totalReplies) {
          showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX reply ${liveProgress.postingReply}/${liveProgress.totalReplies} ê²Œì‹œ ì¤‘...`, 'info');
        } else {
          showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nìŠ¹ì¸ëœ draftë¡œ X ê²Œì‹œ ì¤‘...`, 'info');
        }
        setTimeout(tick, POLL_INTERVAL);
      };
      tick();
    });
  }

  async function runMockPostFlow(commitSha: string) {
    const shortSha = commitSha.slice(0, 7);
    const thread = collectEditedThread();
    if (!thread) {
      showStatus(`[mock] ê²Œì‹œí•  draftë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.`, 'error');
      return;
    }
    const failures = validateThreadLimit(thread.main, thread.replies);
    if (failures.length > 0) {
      const msg = failures.map((f) => `${f.phase} ${f.used}/${X_HARD_LIMIT}`).join(', ');
      showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nê¸¸ì´ ì œí•œ ì´ˆê³¼: ${msg}`, 'error', { autoScroll: true });
      return;
    }

    showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX ê²Œì‹œ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘...`, 'info');
    await sleep(1200);
    for (let i = 0; i < thread.replies.length; i++) {
      showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX reply ${i + 1}/${thread.replies.length} ê²Œì‹œ ì¤‘...`, 'info');
      await sleep(1100);
    }
    showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${shortSha}\nX ê²Œì‹œ ì‹œë®¬ë ˆì´ì…˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success', { autoScroll: true });
    await sleep(4200);
    clearXDraftReview();
    fadeStatusNow();
  }

  function fadeStatusAfter(ms: number) {
    setTimeout(() => {
      const statusEl = document.getElementById('submit-status');
      if (statusEl && !statusEl.classList.contains('hidden')) {
        statusEl.style.transition = 'opacity 0.3s';
        statusEl.style.opacity = '0';
        setTimeout(() => {
          statusEl.classList.add('hidden');
          statusEl.style.opacity = '';
          statusEl.style.transition = '';
        }, 300);
      }
    }, ms);
  }

  function fadeStatusNow() {
    const statusEl = document.getElementById('submit-status');
    if (!statusEl || statusEl.classList.contains('hidden')) return;
    statusEl.style.transition = 'opacity 0.3s';
    statusEl.style.opacity = '0';
    setTimeout(() => {
      statusEl.classList.add('hidden');
      statusEl.style.opacity = '';
      statusEl.style.transition = '';
    }, 300);
  }

  function showStatus(message: string, type: 'info' | 'success' | 'error' | 'warn', opts: { autoScroll?: boolean } = {}) {
    const el = document.getElementById('submit-status');
    if (!el) return;
    el.classList.remove('hidden');
    el.style.opacity = '1';
    el.style.transition = '';
    const styles: Record<string, { box: string; badge: string; dot: string; label: string; pulse?: boolean }> = {
      info: {
        box: 'bg-[#FAF6EE] dark:bg-[#2B251D]/70 text-[#5E4C36] dark:text-[#E8DCC8] border border-[#EADDC9] dark:border-[#4A3F32] ring-1 ring-black/5 dark:ring-white/5',
        badge: 'bg-[#F3E8D5] dark:bg-[#3A3127] text-[#6D5538] dark:text-[#E6D6BC] border border-[#E3D1B6] dark:border-[#5A4B3A]',
        dot: 'bg-[#C9822B]',
        label: 'ì§„í–‰ ì¤‘',
        pulse: true,
      },
      success: {
        box: 'bg-[#FAF6EE] dark:bg-[#2B251D]/70 text-[#5E4C36] dark:text-[#E8DCC8] border border-[#EADDC9] dark:border-[#4A3F32] ring-1 ring-black/5 dark:ring-white/5',
        badge: 'bg-[#F3E8D5] dark:bg-[#3A3127] text-[#6D5538] dark:text-[#E6D6BC] border border-[#E3D1B6] dark:border-[#5A4B3A]',
        dot: 'bg-[#B7772E]',
        label: 'ì™„ë£Œ',
      },
      warn: {
        box: 'bg-[#FBF4E7] dark:bg-[#31281F]/75 text-[#6A4E2D] dark:text-[#F0DFC2] border border-[#E9D3AF] dark:border-[#5B4A37] ring-1 ring-black/5 dark:ring-white/5',
        badge: 'bg-[#F6E5CA] dark:bg-[#433526] text-[#7A5A34] dark:text-[#EED6AF] border border-[#E3C79C] dark:border-[#6A543B]',
        dot: 'bg-[#C47A22]',
        label: 'í™•ì¸ í•„ìš”',
      },
      error: {
        box: 'bg-[#FDF1F1] dark:bg-red-950/25 text-red-800 dark:text-red-200 border border-red-200/90 dark:border-red-800 ring-1 ring-black/5 dark:ring-white/5',
        badge: 'bg-red-100 dark:bg-red-900/50 text-red-700 dark:text-red-300 border border-red-200 dark:border-red-800',
        dot: 'bg-red-500',
        label: 'ì˜¤ë¥˜',
      },
    };
    const selected = styles[type];
    const statusLabel = selected.label;
    const dotClass = selected.pulse ? `${selected.dot} animate-pulse` : selected.dot;
    const displayMessage = message.replace(/^ì»¤ë°‹ ì™„ë£Œ[^\n]*\n?/, '').trim();
    const escaped = escapeHtml(displayMessage).replace(/\n/g, '<br>');
    el.className = `mt-4 mb-5 p-4 rounded-xl text-sm animate-fade-in shadow-sm ${selected.box}`;
    el.innerHTML = `
      <div class="flex items-center gap-2 mb-2">
        <span class="inline-block w-2 h-2 rounded-full ${dotClass}"></span>
        <span class="text-[11px] px-2 py-0.5 rounded-full font-semibold tracking-wide ${selected.badge}">${statusLabel}</span>
      </div>
      <div class="whitespace-pre-line leading-relaxed">${escaped}</div>
    `;

    if (opts.autoScroll) {
      el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }

  function openConfirmModal() {
    const modal = document.getElementById('confirm-modal');
    const msgEl = document.getElementById('confirm-message');
    const listEl = document.getElementById('confirm-item-list');
    if (!modal || !msgEl) return;
    const repo = (document.getElementById('github-repo') as HTMLInputElement)?.value || 'chanmuzi/NLP-Paper-News';
    msgEl.innerHTML = `<span class="font-semibold">${parsedItems.length}ê°œ</span> í•­ëª©ì„ <span class="font-mono text-xs">${escapeHtml(repo)}</span>ì— ì¶”ê°€í•©ë‹ˆë‹¤.`;
    if (listEl) {
      listEl.innerHTML = parsedItems.map(item => {
        const icon = TYPE_ICONS[item.type] || 'ğŸ“œ';
        return `<div class="flex items-center gap-1.5"><span>${icon}</span><span class="truncate">${escapeHtml(item.title)}</span></div>`;
      }).join('');
    }
    const approvalEl = document.getElementById('confirm-manual-approval') as HTMLInputElement | null;
    if (approvalEl) approvalEl.checked = true;
    modal.classList.remove('hidden');
  }

  function closeConfirmModal() {
    document.getElementById('confirm-modal')?.classList.add('hidden');
  }

  // â”€â”€â”€ Submit & Copy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('submit-btn')?.addEventListener('click', () => {
    if (parsedItems.length === 0) {
      showToast('ë¨¼ì € íŒŒì‹± ë˜ëŠ” ë¯¸ë¦¬ë³´ê¸° ì¶”ê°€ë¥¼ ì§„í–‰í•´ì£¼ì„¸ìš”.');
      return;
    }
    const token = localStorage.getItem('github_token');
    if (!token && !isMockMode()) {
      showStatus('GitHub í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ìƒë‹¨ GitHub ë²„íŠ¼ì—ì„œ í† í°ì„ ì…ë ¥í•˜ì„¸ìš”.', 'error');
      return;
    }
    pendingSubmitItems = [...parsedItems];
    openConfirmModal();
  });

  document.getElementById('confirm-submit')?.addEventListener('click', () => {
    const approvalEl = document.getElementById('confirm-manual-approval') as HTMLInputElement | null;
    requireManualApprovalForCurrentSubmit = approvalEl ? approvalEl.checked : true;
    closeConfirmModal();
    if (pendingSubmitItems.length > 0) {
      submitToGitHub(pendingSubmitItems);
      pendingSubmitItems = [];
    }
  });
  document.getElementById('confirm-cancel')?.addEventListener('click', closeConfirmModal);
  document.getElementById('confirm-backdrop')?.addEventListener('click', closeConfirmModal);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeConfirmModal();
  });

  document.getElementById('copy-json')?.addEventListener('click', () => {
    const jsonOutput = document.getElementById('json-output');
    if (jsonOutput) {
      navigator.clipboard.writeText(jsonOutput.textContent || '');
      showToast('JSONì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤');
    }
  });

  document.getElementById('x-approve-post-btn')?.addEventListener('click', async () => {
    const token = localStorage.getItem('github_token');
    const mockMode = isMockMode();
    if (!token && !mockMode) {
      showStatus('GitHub í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤.', 'error');
      return;
    }
    if (!xDraftData || !currentCommittedSha || !currentRepoForSubmit) {
      showStatus('ìŠ¹ì¸í•  X draftê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € í•­ëª©ì„ ì»¤ë°‹í•´ ì£¼ì„¸ìš”.', 'warn');
      return;
    }
    if (!(xMainApproved && xRepliesApproved)) {
      showStatus('ê²Œì‹œ ì „ mainê³¼ repliesë¥¼ ê°ê° ìŠ¹ì¸í•´ ì£¼ì„¸ìš”.', 'warn');
      return;
    }
    if (isPostingInProgress) return;

    try {
      isPostingInProgress = true;
      updateReviewApprovalUi();
      if (mockMode) {
        await runMockPostFlow(currentCommittedSha);
      } else {
        showStatus(`ì»¤ë°‹ ì™„ë£Œ Â· ${currentCommittedSha.slice(0, 7)}\nìŠ¹ì¸ ê²Œì‹œ ì›Œí¬í”Œë¡œ ì‹¤í–‰ ì¤‘...`, 'info');
        const dispatched = await dispatchApprovedPost(currentRepoForSubmit, token!, currentCommittedSha, 'manual_approved');
        if (!dispatched) return;
        await pollApprovedPostStatus(currentRepoForSubmit, token!, currentCommittedSha, Date.now());
      }
    } catch (err: any) {
      showStatus(`ìŠ¹ì¸ ê²Œì‹œ ì‹¤í–‰ ì‹¤íŒ¨: ${err.message}`, 'error');
    } finally {
      isPostingInProgress = false;
      updateReviewApprovalUi();
    }
  });

  document.getElementById('x-main-approve-btn')?.addEventListener('click', () => {
    xMainApproved = !xMainApproved;
    updateReviewApprovalUi();
  });

  document.getElementById('x-replies-approve-btn')?.addEventListener('click', () => {
    xRepliesApproved = !xRepliesApproved;
    updateReviewApprovalUi();
  });

  document.getElementById('x-approve-all-btn')?.addEventListener('click', () => {
    if (isPostingInProgress) return;
    const allApproved = xMainApproved && xRepliesApproved;
    xMainApproved = !allApproved;
    xRepliesApproved = !allApproved;
    updateReviewApprovalUi();
  });

  async function runAiRewrite(target: 'main' | 'replies', instruction: string, replyTarget: 'all' | number = 'all') {
    const token = localStorage.getItem('github_token');
    const mockMode = isMockMode();
    const statusEl = document.getElementById('x-ai-status');
    if ((!token && !mockMode) || !currentRepoForSubmit || !currentCommittedSha) {
      showStatus('AI ìˆ˜ì •ì„ ì‹¤í–‰í•˜ë ¤ë©´ ë¨¼ì € ì»¤ë°‹ í›„ X draftë¥¼ ë¶ˆëŸ¬ì™€ì•¼ í•©ë‹ˆë‹¤.', 'warn');
      return;
    }
    if (!instruction.trim()) {
      showToast('instructionì„ ì…ë ¥í•´ ì£¼ì„¸ìš”.');
      return;
    }
    if (isAiRewriteInProgress) return;

    const scopedInstruction = target === 'main'
      ? `[target: main only]\n${instruction}`
      : replyTarget === 'all'
      ? `[target: all replies]\n${instruction}`
      : `[target: reply ${replyTarget} only; keep others]\n${instruction}`;

    try {
      isAiRewriteInProgress = true;
      const current = collectEditedThread();
      if (!current) throw new Error('í˜„ì¬ threadë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');

      const nextThread = {
        main: current.main,
        replies: [...current.replies],
      };
      let modelName = 'mock-local';
      if (statusEl) statusEl.textContent = `${target === 'main' ? 'main' : 'reply'} AI ìˆ˜ì • ìš”ì²­ ì¤‘...`;

      if (mockMode) {
        if (target === 'main') {
          nextThread.main = mockRewriteMain(nextThread.main, instruction);
          xMainApproved = false;
        } else if (replyTarget === 'all') {
          nextThread.replies = nextThread.replies.map((r, i) => mockRewriteReply(r, instruction, i));
          xRepliesApproved = false;
        } else {
          const idx = replyTarget - 1;
          if (nextThread.replies[idx]) nextThread.replies[idx] = mockRewriteReply(nextThread.replies[idx], instruction, idx);
          xRepliesApproved = false;
        }
      } else {
        await dispatchRewriteDraft(currentRepoForSubmit, token!, currentCommittedSha, scopedInstruction);
        const result = await pollRewriteDraftStatus(currentRepoForSubmit, token!, Date.now());
        if (!result?.payload?.thread?.main) {
          throw new Error('AI ìˆ˜ì • ê²°ê³¼ë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. Actions ë¡œê·¸ ì ‘ê·¼ ê¶Œí•œ(actions:read)ê³¼ ì›Œí¬í”Œë¡œ ìƒíƒœë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.');
        }
        if (!result.payload.success) throw new Error(result.payload.error || 'AI ìˆ˜ì • ì‹¤íŒ¨');
        modelName = String(result.payload.meta?.model || '-');

        if (target === 'main') {
          nextThread.main = String(result.payload.thread.main || nextThread.main);
          xMainApproved = false;
        } else if (replyTarget === 'all') {
          nextThread.replies = Array.isArray(result.payload.thread.replies)
            ? result.payload.thread.replies.map((x: any) => String(x || ''))
            : nextThread.replies;
          xRepliesApproved = false;
        } else {
          const idx = replyTarget - 1;
          const rewrittenReply = Array.isArray(result.payload.thread.replies) ? result.payload.thread.replies[idx] : null;
          if (typeof rewrittenReply === 'string') nextThread.replies[idx] = rewrittenReply;
          xRepliesApproved = false;
        }
      }

      showXDraftReview({
        commitSha: currentCommittedSha,
        thread: nextThread,
        meta: {
          ...(xDraftData?.meta || {}),
          main_model: target === 'main' ? modelName : (xDraftData?.meta?.main_model || '-'),
          reply_model: target === 'replies' ? modelName : (xDraftData?.meta?.reply_model || '-'),
        },
      }, { preserveHistory: true });

      xAiHistory.push({
        at: new Date().toLocaleString('ko-KR'),
        target: target === 'main' ? 'main' : (replyTarget === 'all' ? 'all replies' : `reply ${replyTarget}`),
        instruction,
        model: modelName,
        summary: `main ${countXChars(nextThread.main)}ì Â· replies ${nextThread.replies.length}ê±´`,
      });
      renderAiHistory();
      if (statusEl) statusEl.textContent = 'ì™„ë£Œ';
      showToast('AI ìˆ˜ì • ê²°ê³¼ë¥¼ ë°˜ì˜í–ˆìŠµë‹ˆë‹¤.');
    } catch (err: any) {
      if (statusEl) statusEl.textContent = 'ì‹¤íŒ¨';
      showStatus(`AI ìˆ˜ì • ì‹¤íŒ¨: ${err.message}`, 'error');
    } finally {
      isAiRewriteInProgress = false;
    }
  }

  document.getElementById('x-ai-main-rewrite-btn')?.addEventListener('click', async () => {
    const input = document.getElementById('x-ai-main-instruction') as HTMLTextAreaElement | null;
    const instruction = input?.value.trim() || '';
    await runAiRewrite('main', instruction, 'all');
    if (input) input.value = '';
  });

  document.getElementById('x-ai-reply-rewrite-btn')?.addEventListener('click', async () => {
    const input = document.getElementById('x-ai-reply-instruction') as HTMLTextAreaElement | null;
    const targetEl = document.getElementById('x-ai-reply-target') as HTMLSelectElement | null;
    const instruction = input?.value.trim() || '';
    const selected = targetEl?.value || 'all';
    const replyTarget: 'all' | number = selected === 'all' ? 'all' : Number(selected);
    await runAiRewrite('replies', instruction, replyTarget);
    if (input) input.value = '';
  });

  document.getElementById('x-copy-thread-btn')?.addEventListener('click', async () => {
    const thread = collectEditedThread();
    if (!thread) return;
    const text = [
      '=== MAIN ===',
      thread.main,
      ...thread.replies.flatMap((r, i) => ['', `=== REPLY ${i + 1} ===`, r]),
    ].join('\n');
    await navigator.clipboard.writeText(text);
    showToast('X ìŠ¤ë ˆë“œê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤');
  });

  document.getElementById('x-copy-main-btn')?.addEventListener('click', async () => {
    const thread = collectEditedThread();
    if (!thread) return;
    await navigator.clipboard.writeText(thread.main || '');
    showToast('main postë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤');
  });

  document.getElementById('x-copy-replies-btn')?.addEventListener('click', async () => {
    const thread = collectEditedThread();
    if (!thread) return;
    const text = thread.replies.map((r, i) => `=== REPLY ${i + 1} ===\n${r}`).join('\n\n');
    await navigator.clipboard.writeText(text);
    showToast('repliesë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤');
  });

  // â”€â”€â”€ GitHub token â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function updateTokenStatus() {
    const statusEl = document.getElementById('token-status');
    const token = localStorage.getItem('github_token');
    const mockMode = isMockMode();
    if (statusEl) {
      if (mockMode) {
        statusEl.textContent = 'MOCK';
        statusEl.className = 'inline-flex items-center gap-1 px-1.5 py-0.5 rounded-full text-xs bg-violet-100 dark:bg-violet-900/30 text-violet-600 dark:text-violet-400';
      } else if (token) {
        statusEl.textContent = 'ì—°ê²°ë¨';
        statusEl.className = 'inline-flex items-center gap-1 px-1.5 py-0.5 rounded-full text-xs bg-emerald-100 dark:bg-emerald-900/30 text-emerald-600 dark:text-emerald-400';
      } else {
        statusEl.textContent = 'ë¯¸ì—°ê²°';
        statusEl.className = 'inline-flex items-center gap-1 px-1.5 py-0.5 rounded-full text-xs bg-gray-100 dark:bg-gray-800 text-gray-400';
      }
    }
  }

  document.getElementById('toggle-settings')?.addEventListener('click', () => {
    document.getElementById('settings-panel')?.classList.toggle('hidden');
  });
  document.getElementById('save-token')?.addEventListener('click', () => {
    const input = document.getElementById('github-token') as HTMLInputElement;
    if (input.value.trim()) {
      localStorage.setItem('github_token', input.value.trim());
      input.value = '';
      updateTokenStatus();
      loadExistingIds(); // Reload with new token
      showToast('í† í°ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
      resumeWorkflowTrackingIfNeeded();
    }
  });
  document.getElementById('clear-token')?.addEventListener('click', () => {
    localStorage.removeItem('github_token');
    updateTokenStatus();
    showToast('í† í°ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
  });

  document.getElementById('mock-mode-toggle')?.addEventListener('change', (e) => {
    const enabled = (e.target as HTMLInputElement).checked;
    setMockMode(enabled);
    updateTokenStatus();
    showToast(enabled ? 'ë¡œì»¬ mock ëª¨ë“œê°€ ì¼œì¡ŒìŠµë‹ˆë‹¤' : 'ë¡œì»¬ mock ëª¨ë“œê°€ êº¼ì¡ŒìŠµë‹ˆë‹¤');
  });

  function showToast(message: string) {
    const existing = document.querySelector('.toast');
    if (existing) existing.remove();
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
  }

  function resumeWorkflowTrackingIfNeeded() {
    if (hasActiveWorkflowTracking) return;
    const state = loadWorkflowTracking();
    if (!state) return;

    // ì˜¤ë˜ëœ ì„¸ì…˜ì€ ìë™ íê¸° (2ì‹œê°„)
    if (Date.now() - state.startedAt > 2 * 60 * 60 * 1000) {
      clearWorkflowTracking();
      return;
    }

    const token = localStorage.getItem('github_token');
    if (!token) {
      showStatus('ì§„í–‰ ì¤‘ì´ë˜ ì›Œí¬í”Œë¡œ ì´ë ¥ì´ ìˆìŠµë‹ˆë‹¤. í† í°ì„ ë‹¤ì‹œ ì €ì¥í•˜ë©´ ìƒíƒœë¥¼ ë³µêµ¬í•©ë‹ˆë‹¤.', 'warn');
      return;
    }

    showStatus(`ì´ì „ ì›Œí¬í”Œë¡œ ìƒíƒœ ë³µêµ¬ ì¤‘... Â· ${state.commitSha.slice(0, 7)}`, 'info');
    startWorkflowTracking(state.repo, token, state.commitSha, state.expectedReplies, state.startedAt, state.requireManualApproval !== false);
  }

  window.addEventListener('beforeunload', (e) => {
    if (!hasActiveWorkflowTracking) return;
    e.preventDefault();
    e.returnValue = '';
  });

  // â”€â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (!isLocalDevHost()) {
    setMockMode(false);
  }
  updateTokenStatus();
  const mockModeToggle = document.getElementById('mock-mode-toggle') as HTMLInputElement | null;
  if (mockModeToggle) {
    if (!isLocalDevHost()) {
      mockModeToggle.checked = false;
      mockModeToggle.disabled = true;
      mockModeToggle.closest('label')?.classList.add('opacity-50', 'pointer-events-none');
      const hint = document.createElement('div');
      hint.className = 'mt-1 text-[11px] text-gray-400';
      hint.textContent = 'mock ëª¨ë“œëŠ” ë¡œì»¬ ê°œë°œ ì„œë²„(localhost)ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
      mockModeToggle.closest('label')?.parentElement?.appendChild(hint);
    } else {
      mockModeToggle.checked = isMockMode();
    }
  }
  const savedRepo = localStorage.getItem('github_repo');
  if (savedRepo) {
    (document.getElementById('github-repo') as HTMLInputElement).value = savedRepo;
  }
  loadExistingIds(); // Load after repo value is restored
  document.getElementById('github-repo')?.addEventListener('change', (e) => {
    localStorage.setItem('github_repo', (e.target as HTMLInputElement).value);
    loadExistingIds(); // Reload for new repo
  });
  resumeWorkflowTrackingIfNeeded();
</script>
